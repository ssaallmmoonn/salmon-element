# 从0到1手搓UI组件库（高仿ElementUI组件库）

## 项目的初始化

https://ericwxy.github.io/eric-wiki/my-projects/eric-ui/start.html

### 一、git相关

```cmd
// 项目文件目录下cmd
git init 
```

```bash
# 接着打开bash进行操作
$ vim .gitignore

# 把以下内容copy进去
*.log
npm-debug.Log*
yarn-debug.Log*
yarn-error.log*
pnpm-debug.Log*
Lerna-debug.Log*

node_modules
coverage
dist
dist-ssr
*.local

/cyperss/videos/
/cypress/srceenshots/

.vitepress/dist
.vitepress/cache

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

### 二、项目相关

> 创建packages文件夹

> 创建pnpm-workspace.yaml文件，键入**packages**: -"packages/*"

> 终端执行`pnpm init`

> 在packages文件夹下创建文件夹：
>
> components 所有组件都在这开发
>
> core npm包的入口
>
> docs 项目文档
>
> hooks 一些自定义钩子和一些组合式api
>
> theme 样式
>
> utils 工具函数
>
> pnpm init初始化上面每个文件夹

> 在components core docs hooks theme utils play文件夹下对应的package.json文件进行修改
>
> 除了core的package.json文件配置项中改成"name": "salmon-element"
>
> 其他的package.json文件配置项都改成"name": "@salmon-element/components"，其他的类似

> 在packages文件夹下用vite创建play文件夹（测试用的vue3项目）
>
> pnpm create vite play --template vue-ts

> node版本控制相关
>
> 在根目录下创建文件.nvmrc并输入下面内容
>
> ```
> v18.17.0
> ```
>
> 在项目开始前执行此命令可以确保在该项目选择的node版本是18.17.0
>
> ```bash
> nvm use $(cat .nvmrc)
> ```
>
> 其实就是用了下nvm use而已



### 三、安装依赖和配置依赖

> 安装根目录的依赖
>
> 开发依赖如下：
>
> pnpm add -Dw typescript@^5.2.2 vite@^5.1.4 vitest@^1.4.0 vue-tsc@^1.8.27 postcss-color-mix@^1.1.0 postcss-each@^1.1.0 postcss-each-variables@^0.3.0 postcss-for@^2.1.1 postcss-nested@^6.0.1 @types/node@^20.11.20 @types/lodash-es@^4.17.12 @vitejs/plugin-vue@^5.0.4 @vitejs/plugin-vue-jsx@^3.1.0 @vue/tsconfig@^0.5.1
>
> 非开发依赖：
>
> pnpm add -w lodash-es@^4.17.21 vue@^3.4.19

在根目录 package.json 中添加如下内容

```
{
  "dependencies": {
    "salmon-element": "workspace:*",
    "@salmon-element/hooks": "workspace:*",
    "@salmon-element/utils": "workspace:*",
    "@salmon-element/theme": "workspace:*"
  }
}
```

接下来安装子包的一些依赖

`components`

> pnpm add -D @vue/test-utils@^2.4.5 @vitest/coverage-v8@^1.4.0 jsdom@^24.0.0 --filter @salmon-element/components
> pnpm add @popperjs/core@^2.11.8 async-validator@^4.2.5 --filter @salmon-element/components

`core`

core可以看作是components的唯一出口，所以连接components就可以了

在 core/package.json 中添加如下内容

```
{
  "dependencies": {
    "@salmon-element/components": "workspace:*"
  }
}
```

`docs`

> pnpm add -D vitepress@1.0.0-rc.44 --filter @salmon-element/docs

`pkay`

> 将 play/package.json 中冗余部分删除
>
> <img src="./assets/image-20250309142045654.png" alt="image-20250309142045654" style="zoom:33%;" />
>
> 接着把play文件夹下的tsconfig.json和tsconfig.node.json也删掉，因为会写一个全局的

`写全局tsconfig`

在salmon-element文件夹目录下创建tsconfig.json

```
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "jsxImportSource": "vue",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["packages/**/*.ts", "packages/**/*.tsx", "packages/**/*.vue"]
}
```

在salmon-element文件夹目录下创建tsconfig.node.json

```
{
	"extends": "@tsconfig/node18/tsconfig.json",
	"include": ["packages/**/**.config.ts"],
	"compilerOptions": {
		"composite": true,
		"module": "ESNext",
		"moduleResolution": "Bundler",
		"types": ["node"]
	}
}
```

在salmon-element文件夹目录下创建postcss.config.cjs

```
/* eslint-env node */
module.exports = {
  plugins: [
    require("postcss-nested"),
    require("postcss-each-variables"),
    require("postcss-each")({
      plugins: {
        beforeEach: [require("postcss-for"), require("postcss-color-mix")],
      },
    }),
  ],
};
```

### 四、创建所有分包的入口

创建入口之前需要在根目录（即salmon-element下）跑一次pnpm install

创建之前在utils下创建install.ts，负责所有vue插件的安装

```ts
import type { App, Plugin } from 'vue';
import { each } from 'lodash-es';

//定义类型：一个带有安装功能的单文件组件
//表示 SFCWithInstall 是组件类型 T 和 Plugin 的组合。这意味着 SFCWithInstall 类型的组件既可以作为普通的 Vue 组件使用，也可以作为插件安装到 Vue 应用中。
type SFCWithInstall<T> = T & Plugin;

export function makeInstaller(components: Plugin[]) {
	const installer = (app: App) => {
		return each(components, c => app.use(c));
	};

	return installer as Plugin;
}

export const withInstall = <T>(component: T) => {
	(component as SFCWithInstall<T>).install = (app: App) => {
		const name = (component as any).name;
		app.component(name, component as Plugin);
	};

	return component as SFCWithInstall<T>;
};

```





## 项目分析和执行步骤

该项目的需求分析和测试用例是用大模型进行辅助的

ChatGPT、Poe、deepseek、ChandlerAi、kimi

提示词方面公式：身份定位、前提条件、输出限定

### 需求分析

> # 身份定位
>
> - **角色**：互联网产品经理
> - **目标**：产品需求分析和功能点设计
>
> # 需求
>
> 以"[XXX]"形式定义变量用于对话中不同任务的触发指令
> 以"/help" 为触发关键词，列出所有定义的变量`**XXX**`以及代表的任务
>
> 对话过程用中文交流，专业术语可用英文或缩写。
>
> - [XQFX]:(需求分析) 根据给出的内容输出需求分析文档（md）
> - [GNSJ]:(功能设计) 以上文中的 "需求分析文档" 为依据
>
> # 背景
>
> （项目文档地址：https://ericwxy.github.io/eric-ui/components/button.html   ）
>
> 首次可补充提问来完善背景
>
> # 输出规范
>
> - **需求分析**[XQFX]
>   - **格式**：用户调研摘要、竞品对比报告、市场趋势分析。
>   - **内容**：用户痛点、期望功能、安全性需求。
> - **功能点设计**[GNSJ]
>   - **格式**：功能描述、api 设计、交互关系。
>   - **内容**：功能实现细节、用户操作流程、异常处理。
>
> # 示例指令
>
> - **需求分析**：[XQFX]组件库按钮组件。
> - **功能点设计**：[GNSJ]
>
> 请在后续对话中使用上述结构和示例指令来指导任务执行，并最终以md源码呈现。
>
> 
>
> 补充需求：
>
> 目标群体：前端相关工作和学习人员
> 使用场景：web开发、移动开发都兼容
> 优先级：基础样式游侠你寄最高
> 竞品信息：可以参考https://soberjs.com/  、elementplus官网、ant design官网
> 其他需求：指出可以优化的地方，并量化

得到需求文档如下

> 以下是按照要求整理的 Markdown 格式的需求分析和功能点设计文档：
>
> ---
>
> # 需求分析 [XQFX] 组件库按钮组件
>
> ## 用户调研摘要
> 目标用户群体为前端开发人员和学习者，使用场景涵盖 Web 开发和移动开发。用户期望按钮组件具备以下特点：
> - **轻量化**：不引入额外依赖，减少项目体积。
> - **兼容性**：同时支持 Web 和移动开发，适配多种框架和 UI 库。
> - **易用性**：提供丰富的样式和功能，降低开发成本。
> - **自定义能力**：支持自定义主题，满足个性化需求。
> - **文档清晰**：提供详细的文档和示例，便于学习和使用。
>
> ## 竞品对比报告
> | 特性/竞品      | SoberJS | Element Plus | Ant Design | Eric-UI |
> | -------------- | ------- | ------------ | ---------- | ------- |
> | **轻量化**     | ✔️       | ✔️            | ✔️          | ✔️       |
> | **无侵入性**   | ✔️       | ✔️            | ✔️          | ✔️       |
> | **类型支持**   | ✔️       | ✔️            | ✔️          | ✔️       |
> | **自定义主题** | ✔️       | ✔️            | ✔️          | ✔️       |
> | **响应式设计** | ✔️       | ✔️            | ✔️          | ✔️       |
> | **组件丰富度** | ✕       | ✔️            | ✔️          | ✔️       |
> | **文档清晰度** | ✔️       | ✔️            | ✔️          | ✔️       |
> | **加载状态**   | ✔️       | ✔️            | ✔️          | ✔️       |
> | **节流模式**   | ✕       | ✕            | ✕          | ✔️       |
>
> ## 市场趋势分析
> - **轻量化和无侵入性**：随着前端项目复杂度的增加，用户更倾向于使用轻量级且无侵入性的组件库，以减少项目体积和冲突。
> - **自定义能力**：用户对组件的自定义需求越来越高，支持 CSS 变量的主题定制成为趋势。
> - **响应式设计**：随着移动设备的普及，响应式设计成为必备特性。
> - **功能丰富度**：用户期望组件库提供更丰富的功能和样式，以满足多样化的开发需求。
>
> ## 用户痛点
> - **组件丰富度不足**：与 Element Plus 和 Ant Design 相比，Eric-UI 在组件丰富度上存在差距。
> - **文档示例不足**：虽然 Eric-UI 提供了基本的使用示例，但缺乏详细的 API 文档和高级用法示例。
> - **缺少高级功能**：如节流模式等高级功能在竞品中较为常见，但在 Eric-UI 中尚未完善。
>
> ## 期望功能
> - **增加更多组件**：如表单组件（如输入框、选择器）、布局组件（如栅格系统）等，提升组件库的丰富度。
> - **完善文档**：提供更详细的 API 文档和高级用法示例。
> - **添加高级功能**：如节流模式、防抖功能等，提升组件的实用性。
>
> ## 安全性需求
> - **代码安全性**：确保组件库的代码无安全漏洞，符合现代前端开发的安全标准。
> - **数据隐私**：在组件使用过程中，不涉及用户数据的收集和传输，保障用户隐私。
>
> ---
>
> # 功能点设计 [GNSJ]
>
> ## 功能描述
> - **基础样式优化**：提供更丰富的基础样式，包括按钮尺寸、颜色、形状等。
> - **组件丰富度提升**：增加表单组件（如输入框、选择器）、布局组件（如栅格系统）等。
> - **文档完善**：提供详细的 API 文档和高级用法示例，提升用户体验。
> - **高级功能添加**：添加节流模式、防抖功能等，提升组件的实用性。
>
> ## API 设计
> ```typescript
> // 按钮组件
> interface ButtonProps {
>   size?: 'large' | 'default' | 'small';  
>   type?: 'primary' | 'success' | 'warning' | 'danger' | 'info';  
>   plain?: boolean;  
>   round?: boolean;  
>   circle?: boolean;  
>   loading?: boolean;  
>   loadingIcon?: string;  
>   disabled?: boolean;  
>   icon?: string;  
>   autofocus?: boolean;  
>   nativeType?: 'button' | 'submit' | 'reset';  
>   tag?: string | Component;  
>   useThrottle?: boolean;  
>   throttleDuration?: number;  
> }
> 
> // 按钮组组件
> interface ButtonGroupProps {
>   size?: 'large' | 'default' | 'small';  
>   type?: 'primary' | 'success' | 'warning' | 'danger' | 'info';  
>   disabled?: boolean;  
> }
> ```
>
> ## 交互关系
> - **基础样式**：用户可以通过 `size`、`type` 等属性自定义按钮的样式。
> - **加载状态**：用户可以通过 `loading` 属性设置按钮的加载状态，支持自定义加载图标。
> - **节流模式**：用户可以通过 `useThrottle` 属性开启节流模式，避免频繁点击导致的问题。
> - **按钮组**：用户可以通过 `<er-button-group>` 组件对按钮进行分组，支持统一设置样式和禁用状态。
>
> ## 功能实现细节
> - **基础样式优化**：增加更多颜色选项和形状样式，提升视觉效果。
> - **组件丰富度提升**：参考 Element Plus 和 Ant Design，增加表单组件和布局组件。
> - **文档完善**：提供详细的 API 文档和高级用法示例，提升用户体验。
> - **高级功能添加**：实现节流模式和防抖功能，优化用户操作体验。
>
> ## 用户操作流程
> 1. 用户访问 Eric-UI 官网，查看按钮组件的使用文档。
> 2. 用户根据需求选择按钮样式，通过属性设置按钮的尺寸、颜色等。
> 3. 用户在项目中引入 Eric-UI 按钮组件，并根据文档进行开发。
> 4. 用户在使用过程中遇到问题，参考文档或社区寻求帮助。
>
> ## 异常处理
> - **加载失败**：当加载状态出错时，显示错误提示，用户可以通过 `error` 事件处理异常。
> - **禁用状态**：当按钮处于禁用状态时，用户无法点击，点击事件不会触发。
> - **节流模式**：当用户频繁点击按钮时，根据 `throttleDuration` 属性进行节流处理，避免触发过多事件。
>
> ---
>
> 以上是按照 Markdown 格式整理的需求分析和功能点设计文档，您可以根据实际需求进一步调整和完善。

> 你是一个优秀的测开发工程师，现在需要你根据我给你的需求分析文档帮我写测试用例，要求：vitest技术栈，mount，尽量返回JSX虚拟节点的形式，it，test等方法的name属性，用英文描述，以下是需求文档内容...省略（）

> 以下是deepseek跑出来的jsx测试用例
>
> 关键实现说明：
>
> 1. 使用Vitest的mount方法进行组件挂载
> 2. 全面覆盖所有API属性（size/type/disabled等）
> 3. 特殊处理节流功能测试，使用fakeTimers模拟时间
> 4. 验证DOM结构和类名是否符合预期
> 5. 测试按钮组件的不同变体（按钮组、自定义标签）
> 6. 遵循需求文档中的安全性和异常处理要求
> 7. 测试名称使用英文描述符合规范
>
> 可根据实际组件实现细节调整选择器（如.er-button等类名前缀），需要保证与实际组件样式命名规则一致。
>
> ```jsx
> import { describe, expect, test, vi } from 'vitest'
> import { mount } from '@vue/test-utils'
> import Button from './Button.vue'
> 
> describe('Button Component', () => {
>   test('should render default button with correct classes', () => {
>     const wrapper = mount(<Button>Click me</Button>)
>     expect(wrapper.classes()).toContain('er-button')
>     expect(wrapper.classes()).toContain('er-button--default')
>   })
> 
>   test('should render different size classes', () => {
>     const sizes = ['large', 'default', 'small']
>     sizes.forEach(size => {
>       const wrapper = mount(<Button size={size}>{size} button</Button>)
>       expect(wrapper.classes()).toContain(`er-button--${size}`)
>     })
>   })
> 
>   test('should apply type classes correctly', () => {
>     const types = ['primary', 'success', 'warning', 'danger', 'info']
>     types.forEach(type => {
>       const wrapper = mount(<Button type={type}>{type} button</Button>)
>       expect(wrapper.classes()).toContain(`er-button--${type}`)
>     })
>   })
> 
>   test('should handle boolean props properly', () => {
>     const booleanProps = ['plain', 'round', 'circle', 'disabled', 'loading']
>     booleanProps.forEach(prop => {
>       const wrapper = mount(<Button {...{ [prop]: true }}>Test</Button>)
>       expect(wrapper.classes()).toContain(`is-${prop}`)
>     })
>   })
> 
>   test('should show loading state with custom icon', () => {
>     const wrapper = mount(<Button loading loadingIcon="custom-loading">Submit</Button>)
>     expect(wrapper.find('.er-icon').exists()).toBe(true)
>     expect(wrapper.find('.er-icon').html()).toContain('custom-loading')
>   })
> 
>   test('should prevent click when disabled', async () => {
>     const handleClick = vi.fn()
>     const wrapper = mount(<Button disabled onClick={handleClick}>Disabled</Button>)
>     await wrapper.trigger('click')
>     expect(handleClick).not.toHaveBeenCalled()
>   })
> 
>   test('should throttle click events', async () => {
>     const handleClick = vi.fn()
>     const wrapper = mount(
>       <Button 
>         useThrottle 
>         throttleDuration={500}
>         onClick={handleClick}
>       >
>         Throttle
>       </Button>
>     )
>     
>     vi.useFakeTimers()
>     await wrapper.trigger('click')
>     await wrapper.trigger('click')
>     await wrapper.trigger('click')
>     
>     vi.advanceTimersByTime(500)
>     expect(handleClick).toHaveBeenCalledTimes(1)
>     vi.useRealTimers()
>   })
> 
>   test('should render custom tag element', () => {
>     const wrapper = mount(<Button tag="a" href="https://example.com">Link</Button>)
>     expect(wrapper.element.tagName.toLowerCase()).toBe('a')
>     expect(wrapper.attributes('href')).toBe('https://example.com')
>   })
> })
> 
> describe('ButtonGroup Component', () => {
>   test('should apply group styles correctly', () => {
>     const wrapper = mount(
>       <ButtonGroup size="small" type="primary">
>         <Button>First</Button>
>         <Button>Second</Button>
>       </ButtonGroup>
>     )
>     
>     expect(wrapper.classes()).toContain('er-button-group')
>     const buttons = wrapper.findAllComponents(Button)
>     buttons.forEach(btn => {
>       expect(btn.classes()).toContain('er-button--small')
>       expect(btn.classes()).toContain('er-button--primary')
>     })
>   })
> 
>   test('should disable all buttons in group', () => {
>     const wrapper = mount(
>       <ButtonGroup disabled>
>         <Button>One</Button>
>         <Button>Two</Button>
>       </ButtonGroup>
>     )
>     
>     wrapper.findAllComponents(Button).forEach(btn => {
>       expect(btn.classes()).toContain('is-disabled')
>     })
>   })
> })
> ```

### 初始化vitest

### 书写测试用例



## 开始写组件了

`介绍组件文件夹的目录结构`

①每一个组件有单独的文件夹，以Button文件夹为例

②Button.vue就是所有的SFC逻辑

③Button.test.tsx就是所有的测试用例

④types.ts是所有的类型声明

⑤style.css是样式

⑥constants.ts文件包含可能用到的常量

### Button

![image-20250309175023942](./assets/image-20250309175023942.png)

有一个流程：

首先配置好components目录下的vitest.config.ts文件

```ts
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import vueJsx from '@vitejs/plugin-vue-jsx';

// https://vitejs.dev/config/
export default defineConfig({
	plugins: [vue(), vueJsx()],
	test: {
		globals: true,
		environment: 'jsdom',
	},
});

// "test": "vitest --coverage"
```

在项目根目录下的package.json当中进行npm run test配置

<img src="./assets/image-20250309175258752.png" alt="image-20250309175258752" style="zoom:67%;" />

#### ①根据deepseek生成的jsx测试用例代码填入Button.test.tsx文件中

#### ②执行npm run test，会产生下列情况

<img src="./assets/image-20250309175351972.png" alt="image-20250309175351972" style="zoom:67%;" />

10个情况跑通了2个，我们紧接着修改就好

#### ③Button目录下新建types.ts来定义类型

```ts
import type { Component } from 'vue';

export type ButtonType = 'primary' | 'success' | 'warning' | 'danger' | 'info';
export type NativeType = 'button' | 'submit' | 'reset';
export type ButtonSize = 'large' | 'default' | 'small';

export interface ButtonProps {
	tag?: string | Component;
	type?: ButtonType;
	size?: ButtonSize;
	nativeType?: NativeType;
	disabled?: boolean;
	loading?: boolean;
	icon?: string;
	circle?: boolean;
	plain?: boolean;
	round?: boolean;
}
```

#### ④来到Button.vue文件书写逻辑

```ts
<script setup lang="ts">
	import { ref, computed } from 'vue';
	import type { ButtonProps, ButtonEmits, ButtonInstance } from './types';
	import { throttle } from 'lodash-es';
	import YisIcon from '../Icon/Icon.vue';

	defineOptions({
		name: 'YisButton',
	});

	const props = withDefaults(defineProps<ButtonProps>(), {
		tag: 'button',
		nativeType: 'button',
		useThrottle: true,
		throttleDuration: 500,
	});

	const emits = defineEmits<ButtonEmits>();

	const slots = defineSlots();

	const _ref = ref<HTMLButtonElement>();

	// 服务于单个图标的圆形组件
	const iconStyle = computed(() => {
		marginRight: slots.default ? '6px' : 0;
	});

	const handlerBtnClick = (e: MouseEvent) => emits('click', e);

	const handlerBtnClickThrottle = throttle(handlerBtnClick, props.throttleDuration);

	defineExpose<ButtonInstance>({
		ref: _ref,
	});
</script>

<template>
	<component
		ref="_ref"
		class="yis-button"
		:is="tag"
		:autofocus="autofocus"
		:type="tag === 'button' ? nativeType : void 0"
		:diabled="disabled || loading ? true : void 0"
		:class="{
			[`yis-button--${type}`]: type,
			[`yis-button--${size}`]: size,
			'is-plain': plain,
			'is-round': round,
			'is-circle': circle,
			'is-disabled': disabled,
			'is-loading': loading,
		}"
		@click="(e:MouseEvent) => useThrottle ? handlerBtnClickThrottle(e) : handlerBtnClick"
	>
		<!-- loading图标 -->
		<template v-if="loading">
			<slot name="loading">
				<yis-icon
					class="loading-icon"
					:icon="loadingIcon ?? 'spinner'"
					:style="iconStyle"
					size="1x"
					spin
				></yis-icon>
			</slot>
		</template>
		<yis-icon v-if="icon && !loading" :icon="icon" size="1x" :style="iconStyle"></yis-icon>
		<slot></slot>
	</component>
</template>

<style lang="css" scoped>
	@import './style.css';
</style>

```

#### ⑤创建Button目录下index.ts文件，进行install操作和导出全部types

```ts
import Button from './Button.vue';
import { withInstall } from '@salmon-element/utils';

export const YisButton = withInstall(Button);

export * from './types';
```

#### ⑥最后的两处导出操作

在components文件夹下的index.ts

```ts
export * from './Button';
```

在core文件夹下的components.ts

```ts
import { YisButton } from '@salmon-element/components';
import type { Plugin } from 'vue';

export default [YisButton] as Plugin[];
```













## 撰写文档

### 引进StoryBook

pnpm下载完之后删除/play/stories文件夹下的所有文件，创建Button.stories.ts文件

https://storybook.js.org/docs/get-started/frameworks/vue3-vite#/



书写stories文件夹下的Button.stories.ts，参考下面相关文档

https://storybook.org.cn/docs/writing-tests/component-testing





## 打包项目

我们在core文件夹下写一系列打包的配置

要求：

1）umd：用户在安装我们的ui库时，只需要额外引入一个Vue，图标之类的不需要单独引用，但是包的体积会大一些

2）es：做一些体积上的优化，需要引入时把依赖分包出去，让用户去引入对应的依赖

分两种格式：es-module和umd

### ①在core文件夹下创建vite.umd.config.ts文件

```ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';

export default defineConfig({
	plugins: [vue()],
	build: {
		outDir: 'dist/umd',
		lib: {
			entry: resolve(__dirname, './index.ts'),
			name: 'SalmonElement',
			fileName: 'index ',
			formats: ['umd'],
		},
		rollupOptions: {
			external: ['vue'],
			output: {
				exports: 'named',
				globals: {
					vue: 'Vue',
				},
				assetFileNames: assetInfo => {
					if (assetInfo.name === 'style.css') {
						return 'index.css';
					}
					return assetInfo.name as string;
				},
			},
		},
	},
});

```

### ②在core文件夹下创建vite.es.config.ts文件

```ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';
import dts from 'vite-plugin-dts';

export default defineConfig({
	plugins: [vue(), dts()],
	build: {
		outDir: 'dist/es',
		lib: {
			entry: resolve(__dirname, './index.ts'),
			name: 'SalmonElement',
			fileName: 'index ',
			formats: ['es'],
		},
		rollupOptions: {
			external: [
				'vue',
				'@fortawesome/fontawesome-svg-core',
				'@fortawesome/free-solid-svg-icons',
				'@fortawesome/vue-fontawesome',
				'@popperjs/core',
				'async-validator',
			],
			output: {
				assetFileNames: assetInfo => {
					if (assetInfo.name === 'style.css') {
						return 'index.css';
					}
					return assetInfo.name as string;
				},
			},
		},
	},
});

```

开发者在引用我们这个包的时候没有类型提示，所以我们需要安装一个vite的插件来生成类型文件

在当前的core文件夹目录下pnpm add vite-plugin-dts@3.9.1 -D

但是发现生成dist下的es文件夹并不是我们所设想的（比如play也打包出来了，样式要在单独的文件夹），所以在项目根目录下创建tsconfig.build.json来进行设计

### ③在项目根目录下创建tsconfig.build.json来进行设计

```ts
{
	"extends": "@vue/tsconfig/tsconfig.dom.json",
	"compilerOptions": {
		"target": "ES2020",
		"useDefineForClassFields": true,
		"module": "ESNext",
		"lib": ["ES2020", "DOM", "DOM.Iterable"],
		"skipLibCheck": true,

		/* Bundler mode */
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"resolveJsonModule": true,
		"isolatedModules": true,
		"noEmit": true,
		"jsx": "preserve",
		"jsxImportSource": "vue",

		/* Linting */
		"strict": true,
		"noUnusedLocals": true,
		"noUnusedParameters": true,
		"noFallthroughCasesInSwitch": true
	},
	"include": [
		"packages/core/index.ts",
		"packages/hooks/**/*.ts",
		"packages/utils/**/*.ts",
		"packages/components/index.ts",
		"packages/components/**/*.ts",
		"packages/components/**/*.vue"
	],
        "exclude": ["packages/components/vitest.config.ts"]
}
```

### 接着回到vite.es.config.ts进行相应的限制

```ts
...
export default defineConfig({
plugins: [
		vue(),
    	//修改的地方在下面这里
		dts({
			tsconfigPath: '../../tsconfig.build.json',
			outDir: 'dist/types',
		}),
	],
    ...
});
```

### 下一步我们就可以去分包了，依然是vite.es.config.ts

```ts
...
// 把所有组件的名字定义到一个数组里
const COMP_NAMES = [
	'Alert',
	'Button',
	'Collapse',
	'Dropdown',
	'Form',
	'Icon',
	'Input',
	'Loading',
	'Message',
	'MessageBox',
	'Notification',
	'Overlay',
	'Popconfirm',
	'Select',
	'Switch',
	'Tooltip',
	'Upload',
] as const;

export default defineConfig({
	...
	build: {
		...
		rollupOptions: {
			...
			output: {
				assetFileNames: assetInfo => {
					...
				},
                    	  manualChunks(id) {
					if (includes(id, 'node_modules')) return 'vendor';

					if (includes(id, '/packages/hooks')) return 'hooks';

					if (includes(id, '/packages/utils') || includes(id, 'plugin-vue:export-helper'))
						return 'utils';

					// 遍历所有的组件
					for (const item of COMP_NAMES) {
						if (includes(id, `/packages/components/${item}`)) return item;
					}
				},
			},
		},
	},
});

```

最后一步，把入口的样式文件放到dist目录下，这个操作需要引入一个库

在项目根目录下pnpm add move-file-cli@^3.0.0 -Dw

### 然后在core/package.json进行调试部分的添加

```json
...
"scripts": {
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
    		//添加下面这行
		"move-style": "move-file dist/es/index.css dist/index.css"
	},
...
```

接着，我们add另一个包把这些npm的scripts给串联起来

在项目根目录下pnpm add npm-run-all@^4.1.5 -Dw

### 最后修改core/package.json

```json
...
"scripts": {
     	    // 添加下面两行，其中里面的run-s是串行运行，run-p是并行运行
    	   // 通过运行npm build 就可以一起把下面的不同的build给串联起来
		"build": "run-s build-only move-style",
		"build-only": "run-p build-es build-umd",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"move-style": "move-file dist/es/index.css dist/index.css"
	},
...
```

### 最后我们在项目根目录下的package.json进行build调试的增加和一些依赖的跳转

```json
...
"scripts": {
		...
		"build": "pnpm --filter salmon-element run build"
	},
...
```

### 返回来修改core下的package.json。。。。

```json
{
	"name": "salmon-element",
	"version": "1.0.0",
    // 修改起始部分
	"description": "Components library by Vue3 + TS",
	"type": "module",
	"main": "./dist/umd/index.umd.cjs",
	"module": "./dist/es/index.js",
	"types": "./dist/types/core/index.d.ts",
        "files": [
		"dist"
	 ],
	"exports": {
		".": {
			"import": "./dist/es/index.js",
			"require": "./dist/umd/index.umd.cjs",
			"types": "./dist/types/core/index.d.ts"
		},
		"./dist/": {
			"import": "./dist/",
			"require": "./dist/"
		},
		"sideEffects": [
			"./dist/index.css"
		]
	},
    // 修改终止部分
	"scripts": {
		"build": "run-s build-only move-style",
		"build-only": "run-p build-es build-umd",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"move-style": "move-file dist/es/index.css dist/index.css"
	},
	"keywords": [],
	"author": "",
	"license": "ISC",
	"packageManager": "pnpm@10.6.1",
    // 修改起始部分
	"dependencies": {
		"@fortawesome/fortawesome-svg-core": "6.5.1",
		"@fortawesome/free-solid-svg-icons": "6.5.1",
		"@fortawesome/vue-fontawesome": "3.0.6",
		"@popperjs/core": "2.11.8",
		"async-validator": "4.2.5"
	},
	"devDependencies": {
		"vite-plugin-dts": "3.9.1",
		"@salmon-element/components": "workspace:*"
	},
	"peerDependencies": {
		"vue": "^3.4.19"
	}
    // 修改终止部分
}
```

<img src="./assets/image-20250311120117479.png" alt="image-20250311120117479" style="zoom:67%;" />



### 其他做的一些优化

①packages/core/dist/types/core/index.d.ts文件

```ts
declare const installer: import('vue').Plugin;
// 这里的引入改成了相对路径，而不是@...的名字引入，因为打包上线后会无法正常引入
export * from '../components';
export default installer;
```

②packages/components/vitest.config.ts该文件需要在build的时候被排除

所以在根目录的tsconfig.build.json的最下面新增了一个exclude

```json
...
"exclude": ["packages/components/vitest.config.ts"]
...
```

③优化了packages/core/vite.es.config.ts文件中的COMP_NAMES，原本该常量是我们手动输入收集我们自己制作的组件名称（Alert、Button等），现在改为用一个函数去自动读取packages/components下的文件

```ts
...
// 用函数收集组件的名字
function getDirectoriesSync(basePath: string) {
	const entries = readdirSync(basePath, { withFileTypes: true });

	return map(
		filter(entries, entry => entry.isDirectory()),
		entry => entry.name
	);
}

export default defineConfig({
	...
	build: {
		...
		rollupOptions: {
			...
			output: {
				...
				manualChunks(id) {
					...
					// 遍历所有的组件
					for (const item of getDirectoriesSync('../components')) {
						if (includes(id, `/packages/components/${item}`)) return item;
					}
				},
			},
		},
	},
});
```





## 发布npm

### 切换npm源

首先安装nrm（源管理包）：npm install -g nrm，并用nrm ls查看可选择源列表

<img src="./assets/image-20250311125115054.png" alt="image-20250311125115054" style="zoom: 80%;" />

发现我们现在使用的taobao的源，发布npm我们需要先切换回官方的npm源（nrm use npm）

然后注册一个npm官网的账号，接着在项目终端下使用npm login登陆，然后可以npm whoami确认登陆状态

<img src="./assets/image-20250311130518839.png" alt="image-20250311130518839" style="zoom:80%;" />

### 发布

终端切换到core下，输入npm publish，还是有点纪念意义的哈哈

<img src="./assets/449fb13b78df7cfb50c3627f0e8ec5c.png" alt="449fb13b78df7cfb50c3627f0e8ec5c" style="zoom:67%;" />

### 优化发布过程

#### 新增rimraf库

注意到，每一次发布都需要我们手动在core的package.json中修改版本号，非常不智能。接下来为了改进这个，我们引进一个库：pnpm add rimraf@^5.0.7 -Dw，该包可以自动清理上次打包的残余产物（该命令我会报错，我改用了npm i rimraf@^5.0.7 -g）

然后增加core/package.json下的clean命令

```json
"scripts": {
		"build": "run-s clean build-only move-style",
		"build-only": "run-p build-es build-umd",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"move-style": "move-file dist/es/index.css dist/index.css",
		"clean": "rimraf dist" 
	},
```

增加完后，运行npm run build可以发现打包过程中，dist文件夹被删了，然后又创建了新的

#### 新增release库

同样在core目录下，pnpm add release-it -Dw（npm i release-it@^17.2.1 -g）

同样修改core下的package.json

```json
"scripts": {
		"build": "run-s clean build-only move-style",
		"build-only": "run-p build-es build-umd",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"move-style": "move-file dist/es/index.css dist/index.css",
		"clean": "rimraf dist",
		"release": "release-it"
	},
```

#### 补充关于版本号的细节

![image-20250311150951074](./assets/image-20250311150951074.png)

还有一点：当执行release-it的时候，会默认git push 但是他不会选择分支，所以需要执行一下语句让他默认选择master分支 (git push --set-upstream origin master)

