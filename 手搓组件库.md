# 从0到1手搓UI组件库（高仿ElementUI组件库）

## 项目的初始化

https://ericwxy.github.io/eric-wiki/my-projects/eric-ui/start.html

### 一、git相关

```cmd
// 项目文件目录下cmd
git init 
```

```bash
# 接着打开bash进行操作
$ vim .gitignore

# 把以下内容copy进去
*.log
npm-debug.Log*
yarn-debug.Log*
yarn-error.log*
pnpm-debug.Log*
Lerna-debug.Log*

node_modules
coverage
dist
dist-ssr
*.local

/cyperss/videos/
/cypress/srceenshots/

.vitepress/dist
.vitepress/cache

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

### 二、项目相关

> 创建packages文件夹

> 创建pnpm-workspace.yaml文件，键入**packages**: -"packages/*"

> 终端执行`pnpm init`

> 在packages文件夹下创建文件夹：
>
> components 所有组件都在这开发
>
> core npm包的入口
>
> docs 项目文档
>
> hooks 一些自定义钩子和一些组合式api
>
> theme 样式
>
> utils 工具函数
>
> pnpm init初始化上面每个文件夹

> 在components core docs hooks theme utils play文件夹下对应的package.json文件进行修改
>
> 除了core的package.json文件配置项中改成"name": "salmon-element"
>
> 其他的package.json文件配置项都改成"name": "@salmon-element/components"，其他的类似

> 在packages文件夹下用vite创建play文件夹（测试用的vue3项目）
>
> pnpm create vite play --template vue-ts



### 三、安装依赖和配置依赖

> 安装根目录的依赖
>
> 开发依赖如下：
>
> pnpm add -Dw typescript@^5.2.2 vite@^5.1.4 vitest@^1.4.0 vue-tsc@^1.8.27 postcss-color-mix@^1.1.0 postcss-each@^1.1.0 postcss-each-variables@^0.3.0 postcss-for@^2.1.1 postcss-nested@^6.0.1 @types/node@^20.11.20 @types/lodash-es@^4.17.12 @vitejs/plugin-vue@^5.0.4 @vitejs/plugin-vue-jsx@^3.1.0 @vue/tsconfig@^0.5.1
>
> 非开发依赖：
>
> pnpm add -w lodash-es@^4.17.21 vue@^3.4.19

在根目录 package.json 中添加如下内容

```
{
  "dependencies": {
    "salmon-element": "workspace:*",
    "@salmon-element/hooks": "workspace:*",
    "@salmon-element/utils": "workspace:*",
    "@salmon-element/theme": "workspace:*"
  }
}
```

接下来安装子包的一些依赖

`components`

> pnpm add -D @vue/test-utils@^2.4.5 @vitest/coverage-v8@^1.4.0 jsdom@^24.0.0 --filter @salmon-element/components
> pnpm add @popperjs/core@^2.11.8 async-validator@^4.2.5 --filter @salmon-element/components

`core`

core可以看作是components的唯一出口，所以连接components就可以了

在 core/package.json 中添加如下内容

```
{
  "dependencies": {
    "@salmon-element/components": "workspace:*"
  }
}
```

`docs`

> pnpm add -D vitepress@1.0.0-rc.44 --filter @salmon-element/docs

`pkay`

> 将 play/package.json 中冗余部分删除
>
> <img src="./assets/image-20250309142045654.png" alt="image-20250309142045654" style="zoom:33%;" />
>
> 接着把play文件夹下的tsconfig.json和tsconfig.node.json也删掉，因为会写一个全局的

`写全局tsconfig`

在salmon-element文件夹目录下创建tsconfig.json

```
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "jsxImportSource": "vue",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["packages/**/*.ts", "packages/**/*.tsx", "packages/**/*.vue"]
}
```

在salmon-element文件夹目录下创建tsconfig.node.json

```
{
	"extends": "@tsconfig/node18/tsconfig.json",
	"include": ["packages/**/**.config.ts"],
	"compilerOptions": {
		"composite": true,
		"module": "ESNext",
		"moduleResolution": "Bundler",
		"types": ["node"]
	}
}
```

在salmon-element文件夹目录下创建postcss.config.cjs

```
/* eslint-env node */
module.exports = {
  plugins: [
    require("postcss-nested"),
    require("postcss-each-variables"),
    require("postcss-each")({
      plugins: {
        beforeEach: [require("postcss-for"), require("postcss-color-mix")],
      },
    }),
  ],
};
```

### 四、创建所有分包的入口

创建入口之前需要在根目录（即salmon-element下）跑一次pnpm install

创建之前在utils下创建install.ts，负责所有vue插件的安装

```ts
import type { App, Plugin } from 'vue';
import { each } from 'lodash-es';

//定义类型：一个带有安装功能的单文件组件
//表示 SFCWithInstall 是组件类型 T 和 Plugin 的组合。这意味着 SFCWithInstall 类型的组件既可以作为普通的 Vue 组件使用，也可以作为插件安装到 Vue 应用中。
type SFCWithInstall<T> = T & Plugin;

export function makeInstaller(components: Plugin[]) {
	const installer = (app: App) => {
		return each(components, c => app.use(c));
	};

	return installer as Plugin;
}

export const withInstall = <T>(component: T) => {
	(component as SFCWithInstall<T>).install = (app: App) => {
		const name = (component as any).name;
		app.component(name, component as Plugin);
	};

	return component as SFCWithInstall<T>;
};

```



## 开始写组件了

`介绍组件文件夹的目录结构`

①每一个组件有单独的文件夹，以Button文件夹为例

②Button.vue就是所有的SFC逻辑

③Button.test.tsx就是所有的测试用例

④types.ts是所有的类型声明

⑤style.css是样式

⑥constants.ts文件包含可能用到的常量

### Button

/packages/components/Button/Button.vue

去看写的代码好了







