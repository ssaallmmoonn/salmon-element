# 从0到1手搓UI组件库（高仿ElementUI组件库）

## 项目的初始化

https://ericwxy.github.io/eric-wiki/my-projects/eric-ui/start.html

### 一、git相关

```cmd
// 项目文件目录下cmd
git init 
```

```bash
# 接着打开bash进行操作
$ vim .gitignore

# 把以下内容copy进去
*.log
npm-debug.Log*
yarn-debug.Log*
yarn-error.log*
pnpm-debug.Log*
Lerna-debug.Log*

node_modules
coverage
dist
dist-ssr
*.local

/cyperss/videos/
/cypress/srceenshots/

.vitepress/dist
.vitepress/cache

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

### 二、项目相关

> 创建packages文件夹

> 创建pnpm-workspace.yaml文件，键入**packages**: -"packages/*"

> 终端执行`pnpm init`

> 在packages文件夹下创建文件夹：
>
> components 所有组件都在这开发
>
> core npm包的入口
>
> docs 项目文档
>
> hooks 一些自定义钩子和一些组合式api
>
> theme 样式
>
> utils 工具函数
>
> pnpm init初始化上面每个文件夹

> 在components core docs hooks theme utils play文件夹下对应的package.json文件进行修改
>
> 除了core的package.json文件配置项中改成"name": "salmon-element"
>
> 其他的package.json文件配置项都改成"name": "@salmon-element/components"，其他的类似

> 在packages文件夹下用vite创建play文件夹（测试用的vue3项目）
>
> pnpm create vite play --template vue-ts

> node版本控制相关
>
> 在根目录下创建文件.nvmrc并输入下面内容
>
> ```
> v18.17.0
> ```
>
> 在项目开始前执行此命令可以确保在该项目选择的node版本是18.17.0
>
> ```bash
> nvm use $(cat .nvmrc)
> ```
>
> 其实就是用了下nvm use而已



### 三、安装依赖和配置依赖

> 安装根目录的依赖
>
> 开发依赖如下：
>
> pnpm add -Dw typescript@^5.2.2 vite@^5.1.4 vitest@^1.4.0 vue-tsc@^1.8.27 postcss-color-mix@^1.1.0 postcss-each@^1.1.0 postcss-each-variables@^0.3.0 postcss-for@^2.1.1 postcss-nested@^6.0.1 @types/node@^20.11.20 @types/lodash-es@^4.17.12 @vitejs/plugin-vue@^5.0.4 @vitejs/plugin-vue-jsx@^3.1.0 @vue/tsconfig@^0.5.1
>
> 非开发依赖：
>
> pnpm add -w lodash-es@^4.17.21 vue@^3.4.19

在根目录 package.json 中添加如下内容

```
{
  "dependencies": {
    "salmon-element": "workspace:*",
    "@salmon-element/hooks": "workspace:*",
    "@salmon-element/utils": "workspace:*",
    "@salmon-element/theme": "workspace:*"
  }
}
```

接下来安装子包的一些依赖

`components`

> pnpm add -D @vue/test-utils@^2.4.5 @vitest/coverage-v8@^1.4.0 jsdom@^24.0.0 --filter @salmon-element/components
> pnpm add @popperjs/core@^2.11.8 async-validator@^4.2.5 --filter @salmon-element/components

`core`

core可以看作是components的唯一出口，所以连接components就可以了

在 core/package.json 中添加如下内容

```
{
  "dependencies": {
    "@salmon-element/components": "workspace:*"
  }
}
```

`docs`

> pnpm add -D vitepress@1.0.0-rc.44 --filter @salmon-element/docs

`pkay`

> 将 play/package.json 中冗余部分删除
>
> <img src="./assets/image-20250309142045654.png" alt="image-20250309142045654" style="zoom:33%;" />
>
> 接着把play文件夹下的tsconfig.json和tsconfig.node.json也删掉，因为会写一个全局的

`写全局tsconfig`

在salmon-element文件夹目录下创建tsconfig.json

```
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "jsxImportSource": "vue",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["packages/**/*.ts", "packages/**/*.tsx", "packages/**/*.vue"]
}
```

在salmon-element文件夹目录下创建tsconfig.node.json

```
{
	"extends": "@tsconfig/node18/tsconfig.json",
	"include": ["packages/**/**.config.ts"],
	"compilerOptions": {
		"composite": true,
		"module": "ESNext",
		"moduleResolution": "Bundler",
		"types": ["node"]
	}
}
```

在salmon-element文件夹目录下创建postcss.config.cjs

```
/* eslint-env node */
module.exports = {
  plugins: [
    require("postcss-nested"),
    require("postcss-each-variables"),
    require("postcss-each")({
      plugins: {
        beforeEach: [require("postcss-for"), require("postcss-color-mix")],
      },
    }),
  ],
};
```

### 四、创建所有分包的入口

创建入口之前需要在根目录（即salmon-element下）跑一次pnpm install

创建之前在utils下创建install.ts，负责所有vue插件的安装

```ts
import type { App, Plugin } from 'vue';
import { each } from 'lodash-es';

//定义类型：一个带有安装功能的单文件组件
//表示 SFCWithInstall 是组件类型 T 和 Plugin 的组合。这意味着 SFCWithInstall 类型的组件既可以作为普通的 Vue 组件使用，也可以作为插件安装到 Vue 应用中。
type SFCWithInstall<T> = T & Plugin;

export function makeInstaller(components: Plugin[]) {
	const installer = (app: App) => {
		return each(components, c => app.use(c));
	};

	return installer as Plugin;
}

export const withInstall = <T>(component: T) => {
	(component as SFCWithInstall<T>).install = (app: App) => {
		const name = (component as any).name;
		app.component(name, component as Plugin);
	};

	return component as SFCWithInstall<T>;
};

```





## 开发流程

该项目的需求分析和测试用例是用大模型进行辅助的

ChatGPT、Poe、deepseek、ChandlerAi、kimi

提示词方面公式：身份定位、前提条件、输出限定

### 需求分析

> # 身份定位
>
> - **角色**：互联网产品经理
> - **目标**：产品需求分析和功能点设计
>
> # 需求
>
> 以"[XXX]"形式定义变量用于对话中不同任务的触发指令
> 以"/help" 为触发关键词，列出所有定义的变量`**XXX**`以及代表的任务
>
> 对话过程用中文交流，专业术语可用英文或缩写。
>
> - [XQFX]:(需求分析) 根据给出的内容输出需求分析文档（md）
> - [GNSJ]:(功能设计) 以上文中的 "需求分析文档" 为依据
>
> # 背景
>
> （项目文档地址：https://ericwxy.github.io/eric-ui/components/button.html   ）
>
> 首次可补充提问来完善背景
>
> # 输出规范
>
> - **需求分析**[XQFX]
>   - **格式**：用户调研摘要、竞品对比报告、市场趋势分析。
>   - **内容**：用户痛点、期望功能、安全性需求。
> - **功能点设计**[GNSJ]
>   - **格式**：功能描述、api 设计、交互关系。
>   - **内容**：功能实现细节、用户操作流程、异常处理。
>
> # 示例指令
>
> - **需求分析**：[XQFX]组件库按钮组件。
> - **功能点设计**：[GNSJ]
>
> 请在后续对话中使用上述结构和示例指令来指导任务执行，并最终以md源码呈现。
>
> 
>
> 补充需求：
>
> 目标群体：前端相关工作和学习人员
> 使用场景：web开发、移动开发都兼容
> 优先级：基础样式游侠你寄最高
> 竞品信息：可以参考https://soberjs.com/  、elementplus官网、ant design官网
> 其他需求：指出可以优化的地方，并量化

得到需求文档如下

> 以下是按照要求整理的 Markdown 格式的需求分析和功能点设计文档：
>
> ---
>
> # 需求分析 [XQFX] 组件库按钮组件
>
> ## 用户调研摘要
> 目标用户群体为前端开发人员和学习者，使用场景涵盖 Web 开发和移动开发。用户期望按钮组件具备以下特点：
> - **轻量化**：不引入额外依赖，减少项目体积。
> - **兼容性**：同时支持 Web 和移动开发，适配多种框架和 UI 库。
> - **易用性**：提供丰富的样式和功能，降低开发成本。
> - **自定义能力**：支持自定义主题，满足个性化需求。
> - **文档清晰**：提供详细的文档和示例，便于学习和使用。
>
> ## 竞品对比报告
> | 特性/竞品      | SoberJS | Element Plus | Ant Design | Eric-UI |
> | -------------- | ------- | ------------ | ---------- | ------- |
> | **轻量化**     | ✔️       | ✔️            | ✔️          | ✔️       |
> | **无侵入性**   | ✔️       | ✔️            | ✔️          | ✔️       |
> | **类型支持**   | ✔️       | ✔️            | ✔️          | ✔️       |
> | **自定义主题** | ✔️       | ✔️            | ✔️          | ✔️       |
> | **响应式设计** | ✔️       | ✔️            | ✔️          | ✔️       |
> | **组件丰富度** | ✕       | ✔️            | ✔️          | ✔️       |
> | **文档清晰度** | ✔️       | ✔️            | ✔️          | ✔️       |
> | **加载状态**   | ✔️       | ✔️            | ✔️          | ✔️       |
> | **节流模式**   | ✕       | ✕            | ✕          | ✔️       |
>
> ## 市场趋势分析
> - **轻量化和无侵入性**：随着前端项目复杂度的增加，用户更倾向于使用轻量级且无侵入性的组件库，以减少项目体积和冲突。
> - **自定义能力**：用户对组件的自定义需求越来越高，支持 CSS 变量的主题定制成为趋势。
> - **响应式设计**：随着移动设备的普及，响应式设计成为必备特性。
> - **功能丰富度**：用户期望组件库提供更丰富的功能和样式，以满足多样化的开发需求。
>
> ## 用户痛点
> - **组件丰富度不足**：与 Element Plus 和 Ant Design 相比，Eric-UI 在组件丰富度上存在差距。
> - **文档示例不足**：虽然 Eric-UI 提供了基本的使用示例，但缺乏详细的 API 文档和高级用法示例。
> - **缺少高级功能**：如节流模式等高级功能在竞品中较为常见，但在 Eric-UI 中尚未完善。
>
> ## 期望功能
> - **增加更多组件**：如表单组件（如输入框、选择器）、布局组件（如栅格系统）等，提升组件库的丰富度。
> - **完善文档**：提供更详细的 API 文档和高级用法示例。
> - **添加高级功能**：如节流模式、防抖功能等，提升组件的实用性。
>
> ## 安全性需求
> - **代码安全性**：确保组件库的代码无安全漏洞，符合现代前端开发的安全标准。
> - **数据隐私**：在组件使用过程中，不涉及用户数据的收集和传输，保障用户隐私。
>
> ---
>
> # 功能点设计 [GNSJ]
>
> ## 功能描述
> - **基础样式优化**：提供更丰富的基础样式，包括按钮尺寸、颜色、形状等。
> - **组件丰富度提升**：增加表单组件（如输入框、选择器）、布局组件（如栅格系统）等。
> - **文档完善**：提供详细的 API 文档和高级用法示例，提升用户体验。
> - **高级功能添加**：添加节流模式、防抖功能等，提升组件的实用性。
>
> ## API 设计
> ```typescript
> // 按钮组件
> interface ButtonProps {
>   size?: 'large' | 'default' | 'small';  
>   type?: 'primary' | 'success' | 'warning' | 'danger' | 'info';  
>   plain?: boolean;  
>   round?: boolean;  
>   circle?: boolean;  
>   loading?: boolean;  
>   loadingIcon?: string;  
>   disabled?: boolean;  
>   icon?: string;  
>   autofocus?: boolean;  
>   nativeType?: 'button' | 'submit' | 'reset';  
>   tag?: string | Component;  
>   useThrottle?: boolean;  
>   throttleDuration?: number;  
> }
> 
> // 按钮组组件
> interface ButtonGroupProps {
>   size?: 'large' | 'default' | 'small';  
>   type?: 'primary' | 'success' | 'warning' | 'danger' | 'info';  
>   disabled?: boolean;  
> }
> ```
>
> ## 交互关系
> - **基础样式**：用户可以通过 `size`、`type` 等属性自定义按钮的样式。
> - **加载状态**：用户可以通过 `loading` 属性设置按钮的加载状态，支持自定义加载图标。
> - **节流模式**：用户可以通过 `useThrottle` 属性开启节流模式，避免频繁点击导致的问题。
> - **按钮组**：用户可以通过 `<er-button-group>` 组件对按钮进行分组，支持统一设置样式和禁用状态。
>
> ## 功能实现细节
> - **基础样式优化**：增加更多颜色选项和形状样式，提升视觉效果。
> - **组件丰富度提升**：参考 Element Plus 和 Ant Design，增加表单组件和布局组件。
> - **文档完善**：提供详细的 API 文档和高级用法示例，提升用户体验。
> - **高级功能添加**：实现节流模式和防抖功能，优化用户操作体验。
>
> ## 用户操作流程
> 1. 用户访问 Eric-UI 官网，查看按钮组件的使用文档。
> 2. 用户根据需求选择按钮样式，通过属性设置按钮的尺寸、颜色等。
> 3. 用户在项目中引入 Eric-UI 按钮组件，并根据文档进行开发。
> 4. 用户在使用过程中遇到问题，参考文档或社区寻求帮助。
>
> ## 异常处理
> - **加载失败**：当加载状态出错时，显示错误提示，用户可以通过 `error` 事件处理异常。
> - **禁用状态**：当按钮处于禁用状态时，用户无法点击，点击事件不会触发。
> - **节流模式**：当用户频繁点击按钮时，根据 `throttleDuration` 属性进行节流处理，避免触发过多事件。
>
> ---
>
> 以上是按照 Markdown 格式整理的需求分析和功能点设计文档，您可以根据实际需求进一步调整和完善。

> 你是一个优秀的测开发工程师，现在需要你根据我给你的需求分析文档帮我写测试用例，要求：vitest技术栈，mount，尽量返回JSX虚拟节点的形式，it，test等方法的name属性，用英文描述，以下是需求文档内容...省略（）

> 以下是deepseek跑出来的jsx测试用例
>
> 关键实现说明：
>
> 1. 使用Vitest的mount方法进行组件挂载
> 2. 全面覆盖所有API属性（size/type/disabled等）
> 3. 特殊处理节流功能测试，使用fakeTimers模拟时间
> 4. 验证DOM结构和类名是否符合预期
> 5. 测试按钮组件的不同变体（按钮组、自定义标签）
> 6. 遵循需求文档中的安全性和异常处理要求
> 7. 测试名称使用英文描述符合规范
>
> 可根据实际组件实现细节调整选择器（如.er-button等类名前缀），需要保证与实际组件样式命名规则一致。
>
> ```jsx
> import { describe, expect, test, vi } from 'vitest'
> import { mount } from '@vue/test-utils'
> import Button from './Button.vue'
> 
> describe('Button Component', () => {
>   test('should render default button with correct classes', () => {
>     const wrapper = mount(<Button>Click me</Button>)
>     expect(wrapper.classes()).toContain('er-button')
>     expect(wrapper.classes()).toContain('er-button--default')
>   })
> 
>   test('should render different size classes', () => {
>     const sizes = ['large', 'default', 'small']
>     sizes.forEach(size => {
>       const wrapper = mount(<Button size={size}>{size} button</Button>)
>       expect(wrapper.classes()).toContain(`er-button--${size}`)
>     })
>   })
> 
>   test('should apply type classes correctly', () => {
>     const types = ['primary', 'success', 'warning', 'danger', 'info']
>     types.forEach(type => {
>       const wrapper = mount(<Button type={type}>{type} button</Button>)
>       expect(wrapper.classes()).toContain(`er-button--${type}`)
>     })
>   })
> 
>   test('should handle boolean props properly', () => {
>     const booleanProps = ['plain', 'round', 'circle', 'disabled', 'loading']
>     booleanProps.forEach(prop => {
>       const wrapper = mount(<Button {...{ [prop]: true }}>Test</Button>)
>       expect(wrapper.classes()).toContain(`is-${prop}`)
>     })
>   })
> 
>   test('should show loading state with custom icon', () => {
>     const wrapper = mount(<Button loading loadingIcon="custom-loading">Submit</Button>)
>     expect(wrapper.find('.er-icon').exists()).toBe(true)
>     expect(wrapper.find('.er-icon').html()).toContain('custom-loading')
>   })
> 
>   test('should prevent click when disabled', async () => {
>     const handleClick = vi.fn()
>     const wrapper = mount(<Button disabled onClick={handleClick}>Disabled</Button>)
>     await wrapper.trigger('click')
>     expect(handleClick).not.toHaveBeenCalled()
>   })
> 
>   test('should throttle click events', async () => {
>     const handleClick = vi.fn()
>     const wrapper = mount(
>       <Button 
>         useThrottle 
>         throttleDuration={500}
>         onClick={handleClick}
>       >
>         Throttle
>       </Button>
>     )
>     
>     vi.useFakeTimers()
>     await wrapper.trigger('click')
>     await wrapper.trigger('click')
>     await wrapper.trigger('click')
>     
>     vi.advanceTimersByTime(500)
>     expect(handleClick).toHaveBeenCalledTimes(1)
>     vi.useRealTimers()
>   })
> 
>   test('should render custom tag element', () => {
>     const wrapper = mount(<Button tag="a" href="https://example.com">Link</Button>)
>     expect(wrapper.element.tagName.toLowerCase()).toBe('a')
>     expect(wrapper.attributes('href')).toBe('https://example.com')
>   })
> })
> 
> describe('ButtonGroup Component', () => {
>   test('should apply group styles correctly', () => {
>     const wrapper = mount(
>       <ButtonGroup size="small" type="primary">
>         <Button>First</Button>
>         <Button>Second</Button>
>       </ButtonGroup>
>     )
>     
>     expect(wrapper.classes()).toContain('er-button-group')
>     const buttons = wrapper.findAllComponents(Button)
>     buttons.forEach(btn => {
>       expect(btn.classes()).toContain('er-button--small')
>       expect(btn.classes()).toContain('er-button--primary')
>     })
>   })
> 
>   test('should disable all buttons in group', () => {
>     const wrapper = mount(
>       <ButtonGroup disabled>
>         <Button>One</Button>
>         <Button>Two</Button>
>       </ButtonGroup>
>     )
>     
>     wrapper.findAllComponents(Button).forEach(btn => {
>       expect(btn.classes()).toContain('is-disabled')
>     })
>   })
> })
> ```

### 初始化vitest

### 书写测试用例

### 开发组件逻辑

## 开始写组件了

`介绍组件文件夹的目录结构`

①每一个组件有单独的文件夹，以Button文件夹为例

②Button.vue就是所有的SFC逻辑

③Button.test.tsx就是所有的测试用例

④types.ts是所有的类型声明

⑤style.css是样式

⑥constants.ts文件包含可能用到的常量

### Button

![image-20250309175023942](./assets/image-20250309175023942.png)

有一个流程：

首先配置好components目录下的vitest.config.ts文件

```ts
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import vueJsx from '@vitejs/plugin-vue-jsx';

// https://vitejs.dev/config/
export default defineConfig({
	plugins: [vue(), vueJsx()],
	test: {
		globals: true,
		environment: 'jsdom',
	},
});

// "test": "vitest --coverage"
```

在项目根目录下的package.json当中进行npm run test配置

<img src="./assets/image-20250309175258752.png" alt="image-20250309175258752" style="zoom:67%;" />

#### ①根据deepseek生成的jsx测试用例代码填入Button.test.tsx文件中

#### ②执行npm run test，会产生下列情况

<img src="./assets/image-20250309175351972.png" alt="image-20250309175351972" style="zoom:67%;" />

10个情况跑通了2个，我们紧接着修改就好

#### ③Button目录下新建types.ts来定义类型

```ts
import type { Component } from 'vue';

export type ButtonType = 'primary' | 'success' | 'warning' | 'danger' | 'info';
export type NativeType = 'button' | 'submit' | 'reset';
export type ButtonSize = 'large' | 'default' | 'small';

export interface ButtonProps {
	tag?: string | Component;
	type?: ButtonType;
	size?: ButtonSize;
	nativeType?: NativeType;
	disabled?: boolean;
	loading?: boolean;
	icon?: string;
	circle?: boolean;
	plain?: boolean;
	round?: boolean;
}
```

#### ④来到Button.vue文件书写逻辑

```ts
<script setup lang="ts">
	import { ref, computed } from 'vue';
	import type { ButtonProps, ButtonEmits, ButtonInstance } from './types';
	import { throttle } from 'lodash-es';
	import YisIcon from '../Icon/Icon.vue';

	defineOptions({
		name: 'YisButton',
	});

	const props = withDefaults(defineProps<ButtonProps>(), {
		tag: 'button',
		nativeType: 'button',
		useThrottle: true,
		throttleDuration: 500,
	});

	const emits = defineEmits<ButtonEmits>();

	const slots = defineSlots();

	const _ref = ref<HTMLButtonElement>();

	// 服务于单个图标的圆形组件
	const iconStyle = computed(() => {
		marginRight: slots.default ? '6px' : 0;
	});

	const handlerBtnClick = (e: MouseEvent) => emits('click', e);

	const handlerBtnClickThrottle = throttle(handlerBtnClick, props.throttleDuration);

	defineExpose<ButtonInstance>({
		ref: _ref,
	});
</script>

<template>
	<component
		ref="_ref"
		class="yis-button"
		:is="tag"
		:autofocus="autofocus"
		:type="tag === 'button' ? nativeType : void 0"
		:diabled="disabled || loading ? true : void 0"
		:class="{
			[`yis-button--${type}`]: type,
			[`yis-button--${size}`]: size,
			'is-plain': plain,
			'is-round': round,
			'is-circle': circle,
			'is-disabled': disabled,
			'is-loading': loading,
		}"
		@click="(e:MouseEvent) => useThrottle ? handlerBtnClickThrottle(e) : handlerBtnClick"
	>
		<!-- loading图标 -->
		<template v-if="loading">
			<slot name="loading">
				<yis-icon
					class="loading-icon"
					:icon="loadingIcon ?? 'spinner'"
					:style="iconStyle"
					size="1x"
					spin
				></yis-icon>
			</slot>
		</template>
		<yis-icon v-if="icon && !loading" :icon="icon" size="1x" :style="iconStyle"></yis-icon>
		<slot></slot>
	</component>
</template>

<style lang="css" scoped>
	@import './style.css';
</style>

```

#### ⑤创建Button目录下index.ts文件，进行install操作和导出全部types

```ts
import Button from './Button.vue';
import { withInstall } from '@salmon-element/utils';

export const YisButton = withInstall(Button);

export * from './types';
```

#### ⑥最后的两处导出操作

在components文件夹下的index.ts

```ts
export * from './Button';
```

在core文件夹下的components.ts

```ts
import { YisButton } from '@salmon-element/components';
import type { Plugin } from 'vue';

export default [YisButton] as Plugin[];
```



### Collapse

#### ①定义types.ts

```ts
import type { Ref } from 'vue';
export type CollapseItemName = string | number;

export interface CollapseProps {
	modelValue: CollapseItemName[];
	accordion?: boolean;
}

export interface CollapseItemProps {
	name: CollapseItemName;
	title?: string;
	disabled?: boolean;
}

export interface CollapseContext {
	// 有哪些折叠面板属于展开状态，将他们的names存储在数组中
	activeNames: Ref<CollapseItemName[]>;
	handleItemClick(name: CollapseItemName): void;
}

export interface CollapseEmits {
	(e: 'update:modelValue', value: CollapseItemName[]): void;
	(e: 'change', value: CollapseItemName[]): void;
}
```

#### ②编写Collapse.test.tsx

```tsx
import { beforeAll, describe, expect, test, vi } from 'vitest';
import { DOMWrapper, mount, type VueWrapper } from '@vue/test-utils';
// import transitionEvents from './transitionEvents';

import Collapse from './Collapse.vue';
import CollapseItem from './CollapseItem.vue';

const onChange = vi.fn();

let wrapper: VueWrapper, headers: DOMWrapper<Element>[], contents: DOMWrapper<Element>[];

let firstHeader: DOMWrapper<Element>,
	secondHeader: DOMWrapper<Element>,
	disabledHeader: DOMWrapper<Element>,
	firstContent: DOMWrapper<Element>,
	secondContent: DOMWrapper<Element>,
	disabledContent: DOMWrapper<Element>;

describe('Collapse.vue', () => {
	beforeAll(() => {
		wrapper = mount(
			() => (
				<Collapse modelValue={['a']} {...{ onChange }}>
					<CollapseItem name="a" title="title a">
						content a
					</CollapseItem>
					<CollapseItem name="b" title="title b">
						content b
					</CollapseItem>
					<CollapseItem name="c" title="title c" disabled>
						content c
					</CollapseItem>
				</Collapse>
			),
			{
				global: {
					stubs: ['YisIcon'],
				},
				attachTo: document.body, // 最新版本 jsdom 更新缓存 bug
			}
		);

		headers = wrapper.findAll('.yis-collapse-item__header');
		contents = wrapper.findAll('.yis-collapse-item__wapper');

		firstHeader = headers[0];
		secondHeader = headers[1];
		disabledHeader = headers[2];

		firstContent = contents[0];
		secondContent = contents[1];
		disabledContent = contents[2];
	});

	test('测试基础结构以及对应文本', () => {
		// lenght
		expect(headers.length).toBe(3);
		expect(contents.length).toBe(3);

		// title
		expect(firstHeader.text()).toBe('title a');

		// content
		expect(firstHeader.classes()).toContain('is-active');
		expect(firstContent.isVisible()).toBeTruthy();
		expect(secondHeader.classes()).not.toContain('is-active');
		expect(secondContent.isVisible()).toBeFalsy();
		expect(firstContent.text()).toBe('content a');
		expect(secondContent.text()).toBe('content b');
	});

	test('点击标题展开/关闭内容', async () => {
		// events
		await firstHeader.trigger('click');
		expect(firstContent.isVisible()).toBeFalsy();
		await secondHeader.trigger('click');
		expect(secondHeader.classes()).toContain('is-active');
		expect(secondHeader.isVisible()).toBeTruthy();
		expect(firstHeader.classes()).not.toContain('is-active');
		expect(firstContent.isVisible()).toBeFalsy();
	});

	test('发送正确的事件', () => {
		expect(onChange).toHaveBeenCalledTimes(2);
		expect(onChange).toHaveBeenCalledWith([]);
		expect(onChange).toHaveBeenLastCalledWith(['b']);
	});

	test('disabled 内容', async () => {
		// disabled
		expect(disabledHeader.classes()).toContain('is-disabled');
		onChange.mockClear();
		await disabledHeader.trigger('click');
		expect(disabledContent.isVisible()).toBeFalsy();
		expect(onChange).not.toHaveBeenCalled();
	});

	test('modelValue 变更', async () => {
		wrapper.setValue(['b'], 'modelValue');
		await wrapper.vm.$nextTick();
		expect(secondHeader.classes()).toContain('is-active');
		expect(firstHeader.classes()).not.toContain('is-active');
	});

	test('手风琴模式', async () => {
		wrapper = mount(
			() => (
				<Collapse accordion modelValue={['a']} {...{ onChange }}>
					<CollapseItem name="a" title="title a">
						content a
					</CollapseItem>
					<CollapseItem name="b" title="title b">
						content b
					</CollapseItem>
				</Collapse>
			),
			{
				global: {
					stubs: ['YisIcon'],
				},
				attachTo: document.body,
			}
		);

		headers = wrapper.findAll('.yis-collapse-item__header');
		contents = wrapper.findAll('.yis-collapse-item__wapper');

		firstHeader = headers[0];
		secondHeader = headers[1];

		firstContent = contents[0];
		secondContent = contents[1];
		await firstHeader.trigger('click');
		await secondHeader.trigger('click');
		expect(onChange).toHaveBeenCalledTimes(2);
		expect(onChange).toHaveBeenCalledWith(['b']);
		expect(firstHeader.classes()).not.toContain('is-active');
		expect(secondHeader.classes()).toContain('is-active');
	});

	test('手风琴模式 错误处理', () => {
		const warn = vi.spyOn(console, 'warn').mockImplementation(() => {});
		mount(
			() => (
				<Collapse accordion modelValue={['a', 'b']} {...{ onChange }}>
					<CollapseItem name="a" title="title a">
						content a
					</CollapseItem>
					<CollapseItem name="b" title="title b">
						content b
					</CollapseItem>
					<CollapseItem name="c" title="title c" disabled>
						content c
					</CollapseItem>
				</Collapse>
			),
			{
				global: {
					stubs: ['YisIcon'],
				},
			}
		);
		expect(warn.mock.calls).toMatchInlineSnapshot(
			`
        [
          [
            [YisUIError: [YisCollapse] accordion mode should only have one active item],
          ],
        ]
      `
		);
	});
});

// describe('Collapse/transitionEvents.ts', () => {
// 	const wrapper = mount(() => <div></div>);
// 	test('beforeEnter', () => {
// 		transitionEvents.beforeEnter(wrapper.element);
// 		expect(wrapper.element.style.height).toBe('0px');
// 		expect(wrapper.element.style.overflow).toBe('hidden');
// 	});
// 	test('enter', () => {
// 		transitionEvents.enter(wrapper.element);
// 		expect(wrapper.element.style.height).toBe(`${wrapper.element.scrollHeight}px`);
// 	});
// 	test('afterEnter', () => {
// 		transitionEvents.afterEnter(wrapper.element);
// 		expect(wrapper.element.style.height).toBe('');
// 		expect(wrapper.element.style.overflow).toBe('');
// 	});
// 	test('beforeLeave', () => {
// 		transitionEvents.beforeLeave(wrapper.element);
// 		expect(wrapper.element.style.height).toBe(`${wrapper.element.scrollHeight}px`);
// 		expect(wrapper.element.style.overflow).toBe('hidden');
// 	});
// 	test('leave', () => {
// 		transitionEvents.leave(wrapper.element);
// 		expect(wrapper.element.style.height).toBe('0px');
// 	});
// 	test('afterLeave', () => {
// 		transitionEvents.afterLeave(wrapper.element);
// 		expect(wrapper.element.style.height).toBe('');
// 		expect(wrapper.element.style.overflow).toBe('');
// 	});
// });

```

#### ③写好两个SFC（Single File Component）的雏形

Collapse.vue

```vue
<script setup lang="ts">
	import type { CollapseProps, CollapseEmits } from './types';

	defineOptions({
		name: 'YisCollapse',
	});

	const props = defineProps<CollapseProps>();
	const emits = defineEmits<CollapseEmits>();
</script>

<template>
	<div class="yis-collapse">
		<slot></slot>
	</div>
</template>
```

CollapseItem.vue

```vue’
<script setup lang="ts">
	import type { CollapseItemProps } from './types';
	defineOptions({
		name: 'YisCollapseItem',
	});
	defineProps<CollapseItemProps>();
</script>

<template>
	<div class="yis-collapse-item"></div>
</template>
```

#### ④使用依赖注入Constant

constants.ts

```ts
import type { InjectionKey } from 'vue';
import type { CollapseContext } from './types';

// 依赖注入相关的key
export const COLLAPSE_CTX_KEY: InjectionKey<CollapseContext> = Symbol('collapseContext');
```

依赖注入需要使用vue的provide和inject，modelValue（数组，用来存储哪些的折叠框是打开的）需要用到vue的watch，顺便再把constant的key引进来

```vue
<script setup lang="ts">
...
	import { provide, ref, watch } from 'vue';
	import { COLLAPSE_CTX_KEY } from './constants';
...
</script>

```

其实依赖注入就是provide和inject组合啦

#### ⑤运行npm run test检测

在.vue文件中写好所有符合tsx测试逻辑的代码后，就可以run test了

通过啦！！！嘿嘿

<img src="./assets/image-20250311205020539.png" alt="image-20250311205020539" style="zoom:80%;" />

#### ⑥注册并导出组件

第一步：给Collapse组件写一个入口文件，在Collapse目录下创建index.ts

```ts
import Collapse from './Collapse.vue';
import CollapseItem from './CollapseItem.vue';
import { withInstall } from '@salmon-element/utils';

export const YisCollapse = withInstall(Collapse);
export const YisCollapseItem = withInstall(CollapseItem);

export * from './types';
```

第二步：在packages/components目录下的index.ts中向外暴露Collapse组件

```ts
...
export * from './Collapse';
```

第三步：在packages/core目录下的components.ts中增加Callapse相关的代码

```ts
import {
	...
	YisCollapse,
	YisCollapseItem,
} from '@salmon-element/components';
import type { Plugin } from 'vue';

export default [..., YisCollapse, YisCollapseItem] as Plugin[];
```



#### ⑦引入css样式并在storybook中调试组件样式

#### 引入css样式

在Collapse文件夹下创建style.css并把样式写进去

在vue文件中的<style></style>部分@import “./style.css”

#### storybook调试

在play/src/stories目录下创建文件Collapse.stories.ts，并编写代码

```ts
import type { Meta, StoryObj } from '@storybook/vue3';
import { YisCollapse, YisCollapseItem } from 'salmon-element';
import 'salmon-element/dist/index.css';

type Story = StoryObj<typeof YisCollapse>;

const meta: Meta<typeof YisCollapse> = {
	title: 'Example/Collapse',
	component: YisCollapse,
	subcomponents: { YisCollapseItem },
	tags: ['autodocs'],
};

export const Default: Story = {
	render: (args: any) => ({
		components: {
			YisCollapse,
			YisCollapseItem,
		},
		setup() {
			return {
				args,
			};
		},
		template: `
    <yis-collapse v-bind="args">
      <yis-collapse-item name="a" title="Title a">
        <div>this is content a</div>
      </yis-collapse-item>
      <yis-collapse-item name="b" title="title b">
        <div>this is content b</div>
      </yis-collapse-item>
      <yis-collapse-item name="c" title="title c  disable" disabled>
        <div>this is content c</div>
      </yis-collapse-item>
    </yis-collapse>
    `,
	}),
	args: {
		accordion: true,
		modelValue: ['a'],
	},
};

export default meta;
```

由于引入Collapse组件是从core中引入的，所以需要在调试前`先build一次`

又因为我们修改过了根目录下的package.json中的scripts中的run story，该指令会先build一次再run story，所以`其实可以直接npm run story的`

------

**以下是该组件独有的修改，与其他组件的书写不具有通用性**

#### ⑧增加折叠的动画效果

#### 增加过渡效果

可以在vue里面通过@click来写动画的，但是有些许复杂和臃肿，便抽离出来了

在Collapse文件夹目录下创建transitionEvents.ts

```ts
const _setHeightZero = (el: HTMLElement) => (el.style.height = '0px');
const _setHeightScroll = (el: HTMLElement) => (el.style.height = `${el.scrollHeight}px`);
const _setHeightEmpty = (el: HTMLElement) => (el.style.height = '');
const _setOverflowHidden = (el: HTMLElement) => (el.style.overflow = 'hidden');
const _setOverflowEmpty = (el: HTMLElement) => (el.style.overflow = '');

const transitionEvents: Record<string, (el: HTMLElement) => void> = {
	beforeEnter(el) {
		_setHeightZero(el);
		_setOverflowHidden(el);
	},
	enter: el => _setHeightScroll(el),
	afterEnter(el) {
		_setHeightEmpty(el);
		_setOverflowEmpty(el);
	},
	beforeLeave(el) {
		_setHeightScroll(el);
		_setOverflowHidden(el);
	},
	leave: el => _setHeightZero(el),
	afterLeave(el) {
		_setHeightEmpty(el);
		_setOverflowEmpty(el);
	},
};

export default transitionEvents;
```

#### 修改SFC中对应部分

CollapseItem.vue

```vue
<script setup lang="ts">
...
import transitionEvents from './transitionEvents';
</script>

<template>
	<div
		class="yis-collapse-item"
		:class="{
			'is-disabled': disabled,
		}"
	>
		...
		<transition name="slide" v-on="transitionEvents">
			<div class="yis-collapse-item__wapper" v-show="isActive">
				<div class="yis-collapse-item__content" :id="`item-content-${name}`">
					<slot></slot>
				</div>
			</div>
		</transition>
	</div>	
</template>
```



#### ⑨抽离console.warn实现复用性

注意到，在Collapse.vue中，有以下这部分代码，是用来检测手风琴模式的异常行为的

```ts
watchEffect(() => {
	if (props.accordion && activeNames.value.length > 1) {
		console.warn('accordion mode should only have one active item');
	}
});
```

后续开发会有很多场合会用到这个warning，所以我们把这个功能复用到packages/utils下

packages/utils目录下创建error.ts

```ts
import { isString } from 'lodash-es';

class YisUIError extends Error {
	constructor(message: string) {
		super(message);
		this.name = 'YisUIError';
	}
}

export function throwError(scope: string, msg: string) {
	throw new YisUIError(`[${scope}] ${msg}`);
}

// ts里的函数重载，有3种情况
export function debugWarn(error: Error): void;
export function debugWarn(scope: string, msg: string): void;
export function debugWarn(scope: string | Error, msg?: string) {
	if (process.env.NODE_ENV !== 'production') {
		const err = isString(scope) ? new YisUIError(`[${scope}] ${msg}`) : scope;
		console.warn(err);
	}
}
```

然后在同目录下的index.ts入口文件处导出error.ts的全部内容

```ts
...
export * from './error';
```



### Alert

流程依旧是老规矩

#### ①types.ts

#### ②Alert.test.tsx

#### ③SFC（Alert.vue）

根据Alert.test.tsx写对应的vue里的逻辑

不知道写什么可以从下面入手，还是有一些固定的，比如：

defineOptions定义一下组件名

const props接受defineProps，并给一些默认值

const emits，const slots等等

function 。。。

script部分写完了写template里的DOM

#### ④引进样式

#### ⑤注册并导出







## 打包项目

我们在core文件夹下写一系列打包的配置

要求：

1）umd：用户在安装我们的ui库时，只需要额外引入一个Vue，图标之类的不需要单独引用，但是包的体积会大一些

2）es：做一些体积上的优化，需要引入时把依赖分包出去，让用户去引入对应的依赖

分两种格式：es-module和umd

### ①在core文件夹下创建vite.umd.config.ts文件

```ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';

export default defineConfig({
	plugins: [vue()],
	build: {
		outDir: 'dist/umd',
		lib: {
			entry: resolve(__dirname, './index.ts'),
			name: 'SalmonElement',
			fileName: 'index ',
			formats: ['umd'],
		},
		rollupOptions: {
			external: ['vue'],
			output: {
				exports: 'named',
				globals: {
					vue: 'Vue',
				},
				assetFileNames: assetInfo => {
					if (assetInfo.name === 'style.css') {
						return 'index.css';
					}
					return assetInfo.name as string;
				},
			},
		},
	},
});

```

### ②在core文件夹下创建vite.es.config.ts文件

```ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';
import dts from 'vite-plugin-dts';

export default defineConfig({
	plugins: [vue(), dts()],
	build: {
		outDir: 'dist/es',
		lib: {
			entry: resolve(__dirname, './index.ts'),
			name: 'SalmonElement',
			fileName: 'index ',
			formats: ['es'],
		},
		rollupOptions: {
			external: [
				'vue',
				'@fortawesome/fontawesome-svg-core',
				'@fortawesome/free-solid-svg-icons',
				'@fortawesome/vue-fontawesome',
				'@popperjs/core',
				'async-validator',
			],
			output: {
				assetFileNames: assetInfo => {
					if (assetInfo.name === 'style.css') {
						return 'index.css';
					}
					return assetInfo.name as string;
				},
			},
		},
	},
});

```

开发者在引用我们这个包的时候没有类型提示，所以我们需要安装一个vite的插件来生成类型文件

在当前的core文件夹目录下pnpm add vite-plugin-dts@3.9.1 -D

但是发现生成dist下的es文件夹并不是我们所设想的（比如play也打包出来了，样式要在单独的文件夹），所以在项目根目录下创建tsconfig.build.json来进行设计

### ③在项目根目录下创建tsconfig.build.json来进行设计

```ts
{
	"extends": "@vue/tsconfig/tsconfig.dom.json",
	"compilerOptions": {
		"target": "ES2020",
		"useDefineForClassFields": true,
		"module": "ESNext",
		"lib": ["ES2020", "DOM", "DOM.Iterable"],
		"skipLibCheck": true,

		/* Bundler mode */
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"resolveJsonModule": true,
		"isolatedModules": true,
		"noEmit": true,
		"jsx": "preserve",
		"jsxImportSource": "vue",

		/* Linting */
		"strict": true,
		"noUnusedLocals": true,
		"noUnusedParameters": true,
		"noFallthroughCasesInSwitch": true
	},
	"include": [
		"packages/core/index.ts",
		"packages/hooks/**/*.ts",
		"packages/utils/**/*.ts",
		"packages/components/index.ts",
		"packages/components/**/*.ts",
		"packages/components/**/*.vue"
	],
        "exclude": ["packages/components/vitest.config.ts"]
}
```

### 接着回到vite.es.config.ts进行相应的限制

```ts
...
export default defineConfig({
plugins: [
		vue(),
    	//修改的地方在下面这里
		dts({
			tsconfigPath: '../../tsconfig.build.json',
			outDir: 'dist/types',
		}),
	],
    ...
});
```

### 下一步我们就可以去分包了，依然是vite.es.config.ts

```ts
...
// 把所有组件的名字定义到一个数组里
const COMP_NAMES = [
	'Alert',
	'Button',
	'Collapse',
	'Dropdown',
	'Form',
	'Icon',
	'Input',
	'Loading',
	'Message',
	'MessageBox',
	'Notification',
	'Overlay',
	'Popconfirm',
	'Select',
	'Switch',
	'Tooltip',
	'Upload',
] as const;

export default defineConfig({
	...
	build: {
		...
		rollupOptions: {
			...
			output: {
				assetFileNames: assetInfo => {
					...
				},
                    	  manualChunks(id) {
					if (includes(id, 'node_modules')) return 'vendor';

					if (includes(id, '/packages/hooks')) return 'hooks';

					if (includes(id, '/packages/utils') || includes(id, 'plugin-vue:export-helper'))
						return 'utils';

					// 遍历所有的组件
					for (const item of COMP_NAMES) {
						if (includes(id, `/packages/components/${item}`)) return item;
					}
				},
			},
		},
	},
});

```

最后一步，把入口的样式文件放到dist目录下，这个操作需要引入一个库

在项目根目录下pnpm add move-file-cli@^3.0.0 -Dw

### 然后在core/package.json进行调试部分的添加

```json
...
"scripts": {
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
    		//添加下面这行
		"move-style": "move-file dist/es/index.css dist/index.css"
	},
...
```

接着，我们add另一个包把这些npm的scripts给串联起来

在项目根目录下pnpm add npm-run-all@^4.1.5 -Dw

### 最后修改core/package.json

```json
...
"scripts": {
     	    // 添加下面两行，其中里面的run-s是串行运行，run-p是并行运行
    	   // 通过运行npm build 就可以一起把下面的不同的build给串联起来
		"build": "run-s build-only move-style",
		"build-only": "run-p build-es build-umd",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"move-style": "move-file dist/es/index.css dist/index.css"
	},
...
```

### 最后我们在项目根目录下的package.json进行build调试的增加和一些依赖的跳转

```json
...
"scripts": {
		...
		"build": "pnpm --filter salmon-element run build"
	},
...
```

### 返回来修改core下的package.json。。。。

```json
{
	"name": "salmon-element",
	"version": "1.0.0",
    // 修改起始部分
	"description": "Components library by Vue3 + TS",
	"type": "module",
	"main": "./dist/umd/index.umd.cjs",
	"module": "./dist/es/index.js",
	"types": "./dist/types/core/index.d.ts",
        "files": [
		"dist"
	 ],
	"exports": {
		".": {
			"import": "./dist/es/index.js",
			"require": "./dist/umd/index.umd.cjs",
			"types": "./dist/types/core/index.d.ts"
		},
		"./dist/": {
			"import": "./dist/",
			"require": "./dist/"
		},
		"sideEffects": [
			"./dist/index.css"
		]
	},
    // 修改终止部分
	"scripts": {
		"build": "run-s build-only move-style",
		"build-only": "run-p build-es build-umd",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"move-style": "move-file dist/es/index.css dist/index.css"
	},
	"keywords": [],
	"author": "",
	"license": "ISC",
	"packageManager": "pnpm@10.6.1",
    // 修改起始部分
	"dependencies": {
		"@fortawesome/fortawesome-svg-core": "6.5.1",
		"@fortawesome/free-solid-svg-icons": "6.5.1",
		"@fortawesome/vue-fontawesome": "3.0.6",
		"@popperjs/core": "2.11.8",
		"async-validator": "4.2.5"
	},
	"devDependencies": {
		"vite-plugin-dts": "3.9.1",
		"@salmon-element/components": "workspace:*"
	},
	"peerDependencies": {
		"vue": "^3.4.19"
	}
    // 修改终止部分
}
```

<img src="./assets/image-20250311120117479.png" alt="image-20250311120117479" style="zoom:67%;" />



### 其他做的一些优化

①packages/core/dist/types/core/index.d.ts文件

```ts
declare const installer: import('vue').Plugin;
// 这里的引入改成了相对路径，而不是@...的名字引入，因为打包上线后会无法正常引入
export * from '../components';
export default installer;
```

②packages/components/vitest.config.ts该文件需要在build的时候被排除

所以在根目录的tsconfig.build.json的最下面新增了一个exclude

```json
...
"exclude": ["packages/components/vitest.config.ts"]
...
```

③优化了packages/core/vite.es.config.ts文件中的COMP_NAMES，原本该常量是我们手动输入收集我们自己制作的组件名称（Alert、Button等），现在改为用一个函数去自动读取packages/components下的文件

```ts
...
// 用函数收集组件的名字
function getDirectoriesSync(basePath: string) {
	const entries = readdirSync(basePath, { withFileTypes: true });

	return map(
		filter(entries, entry => entry.isDirectory()),
		entry => entry.name
	);
}

export default defineConfig({
	...
	build: {
		...
		rollupOptions: {
			...
			output: {
				...
				manualChunks(id) {
					...
					// 遍历所有的组件
					for (const item of getDirectoriesSync('../components')) {
						if (includes(id, `/packages/components/${item}`)) return item;
					}
				},
			},
		},
	},
});
```



## 发布npm

### 切换npm源

首先安装nrm（源管理包）：npm install -g nrm，并用nrm ls查看可选择源列表

<img src="./assets/image-20250311125115054.png" alt="image-20250311125115054" style="zoom: 80%;" />

发现我们现在使用的taobao的源，发布npm我们需要先切换回官方的npm源（nrm use npm）

然后注册一个npm官网的账号，接着在项目终端下使用npm login登陆，然后可以npm whoami确认登陆状态

<img src="./assets/image-20250311130518839.png" alt="image-20250311130518839" style="zoom:80%;" />

### 发布

终端切换到core下，输入npm publish，还是有点纪念意义的哈哈

<img src="./assets/449fb13b78df7cfb50c3627f0e8ec5c.png" alt="449fb13b78df7cfb50c3627f0e8ec5c" style="zoom:67%;" />

### 优化发布过程

#### 新增rimraf库

注意到，每一次发布都需要我们手动在core的package.json中修改版本号，非常不智能。接下来为了改进这个，我们引进一个库：pnpm add rimraf@^5.0.7 -Dw，该包可以自动清理上次打包的残余产物（该命令我会报错，我改用了npm i rimraf@^5.0.7 -g）

然后增加core/package.json下的clean命令

```json
"scripts": {
		"build": "run-s clean build-only move-style",
		"build-only": "run-p build-es build-umd",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"move-style": "move-file dist/es/index.css dist/index.css",
		"clean": "rimraf dist" 
	},
```

增加完后，运行npm run build可以发现打包过程中，dist文件夹被删了，然后又创建了新的

#### 新增release库

同样在core目录下，pnpm add release-it -Dw（npm i release-it@^17.2.1 -g）

同样修改core下的package.json

```json
"scripts": {
		"build": "run-s clean build-only move-style",
		"build-only": "run-p build-es build-umd",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"move-style": "move-file dist/es/index.css dist/index.css",
		"clean": "rimraf dist",
		"release": "release-it"
	},
```

#### 补充关于版本号的细节

![image-20250311150951074](./assets/image-20250311150951074.png)

还有一点：当执行release-it的时候，会默认git push 但是他不会选择分支，所以需要执行一下语句让他默认选择master分支 (git push --set-upstream origin master)

在根目录下以此执行 （这一步一定要在release之前，因为release会push）：

git add .

git commit

然后切回来core目录下（因为根目录下的package.json还没增加release的scripts呵呵呵hhh）执行npm run release

<img src="./assets/image-20250311152037944.png" alt="image-20250311152037944" style="zoom:67%;" />

成功啦！可以发现npm官网上发布的版本号自动变更了，github上也更新了



## 搭建组件文档

技术栈：vitepress，第三方库vitepress-demo-preview

唉







## 坑和未解的bug

> 在git push之前，因为在test-and-deploy.yml文件中跑了这条命令**run**: pnpm install --frozen-lockfile，所以当我们更新了依赖之后，我们需要在根目录删了lock文件，然后再运行一次pnpm install，就可以避免这个错误。
>

> 3月12日遗留bug
>
> ①components下run test的error
>
> ![f6f71c61fb97fa67e8ab4c09bbfaaa7](./assets/f6f71c61fb97fa67e8ab4c09bbfaaa7.png)
>
> 解决办法：根目录下创建vitest.setup.ts
>
> ```ts
> import { library } from '@fortawesome/fontawesome-svg-core';
> import { fas } from '@fortawesome/free-solid-svg-icons';
> 
> library.add(fas);
> ```
>
> 然后在根目录下的vitest.config.ts（之前从packages/components拖到根目录下了，因为要把utils里也达到100%）里进行配置
>
> ```ts
> /// <reference types="vitest" />
> import { defineConfig } from 'vite';
> import vue from '@vitejs/plugin-vue';
> import vueJsx from '@vitejs/plugin-vue-jsx';
> import { resolve } from 'path';
> 
> // https://vitejs.dev/config/
> export default defineConfig({
> 	plugins: [vue(), vueJsx()],
> 	define: {
> 		PROD: JSON.stringify(false),
> 		DEV: JSON.stringify(false),
> 		TEST: JSON.stringify(true),
> 	},
> 	test: {
> 		globals: true,
> 		environment: 'jsdom',
>      	// 添加下面这行
> 		setupFiles: [resolve(__dirname, './vitest.setup.ts')],
> 	},
> });
> ```
>
> 
>
> ②vitepress里面的配置，找不到自己封装的模块
>
> ![693160222fe9eea637d26da0da8714a](./assets/693160222fe9eea637d26da0da8714a.png)
>
> 为vitepress-preview-component打包后 解决





## 优化

### 第一次优化

时间：在写完Collapse之后

#### 样式的分包

实现的效果：项目打包之后，实现每个组件单独的样式为各自单独的css文件，然后统一收集在dist文件夹下theme文件夹里，实现按需引入的需求；当然了，全部引入的话可以直接引入dist下的index.css。

开始改造吧~

首先来到 packages/core/vite.es.config.ts（注释部分是添加内容）

```ts
...
export default defineConfig({
	build: {
		 ...
         	 cssCodeSplit: true,
        	...
             rollupOptions: {
                 ...
                 output: {
                     assetFileNames: assetInfo => {
					if (assetInfo.name === 'style.css') {
						return 'index.css';
					}
                         		// 添加了下面这个if
					if (assetInfo.type === 'asset' && /\.(css)$/i.test(assetInfo.name as string)) {
						return 'theme/[name].[ext]';
					}
					return assetInfo.name as string;
				},
                     ...
                 }
             }
	},
});
```



#### umd打包的样式压缩

实现的效果：得到打包后的umd文件夹下的每个文件的gz压缩包。（这个gz怎么用？服务端配置nginx或者上传到CDN，作为组件库，我们做到这一步已足够）

首先需要在core终端下引入一个插件，pnpm add vite-plugin-compression2 -D

然后来修改vite.umd.config.ts

```ts
...
import { compression } from 'vite-plugin-compression2';

export default defineConfig({
    plugins: [vue(), compression({
			include: /.(cjs|css)$/i,
			})
             	],
    ...
});
```



#### hooksPlugin.ts文件

先在根目录下，引入一个库：pnpm add shelljs -wD，不知道为什么我还需要pnpm install --save-dev @types/shelljs才不会报错

然后删掉根目录下的package.json里的rimraf和move-file-cli两个依赖

删掉core下的package.json里的scripts里的“clean”和“move-style”

```ts
// 该hooks文件的目的：
// 1）开始打包之前，我们把之前的打包产物清理掉
// 2）打包后，再做一些别的操作

import { each, isFunction } from 'lodash-es';
import shell from 'shelljs';

export default function hooksPlugin({
	rmFiles = [],
	beforeBuild,
	afterBuild,
}: {
	rmFiles?: string[];
	beforeBuild?: Function;
	afterBuild?: Function;
}) {
	return {
		name: 'hooks-plugin',
		buildStart() {
			each(rmFiles, fName => shell.rm('-rf', fName));
			isFunction(beforeBuild) && beforeBuild();
		},
		buildEnd(err?: Error) {
			!err && isFunction(afterBuild) && afterBuild();
		},
	};
}
```

修改vite.umd.config.ts

```ts
...
import { readFileSync } from 'fs';
import { delay } from 'lodash-es';
import shell from 'shelljs';
import hooks from './hooksPlugin

// 把dist/umd/index.css给复制到外边和umd同级
// 这个index.css.gz是全部组件的样式的压缩包
const TRY_MOVE_STYLES_DELAY = 800 as const;
function moveStyles() {
    //使用try-catch的原因：在打包过程中可能文件还没出来就执行了moveStyle函数，当出现这种情况，会显示no such file，这时候我们就可以等800ms之后再moveStyle一次就没什么问题了
	try {
		readFileSync('./dist/umd/index.css.gz');
		shell.cp('./dist/umd/index.css', './dist/index.css');
	} catch (_) {
		delay(moveStyles, TRY_MOVE_STYLES_DELAY);
	}
}

export default defineConfig({
    plugins: [
		...
		hooks({
			rmFiles: ['./dist/umd', './dist/index.css'],
            	  afterBuild: moveStyles,
		}),
	],
    ...
});
```

同样的，需要在vite.es.config.ts里做出对应修改

```ts
...
import { readdirSync } from 'fs';
import { delay } from 'lodash-es';
import shell from 'shelljs';
import hooks from './hooksPlugin'

// 打包时的样式文件移动位置
const TRY_MOVE_STYLES_DELAY = 800 as const;
function moveStyles() {
	try {
		readdirSync('./dist/es/theme');
		shell.mv('./dist/es/theme', './dist');
	} catch (_) {
		delay(moveStyles, TRY_MOVE_STYLES_DELAY);
	}
}

export default defineConfig({
    plugins: [
		...
		hooks({
			rmFiles: ['./dist/es', './dist/theme', './dist/types'],
			afterBuild: moveStyles,
		}),
	],
    ...
})
```





#### core入口文件的优化

优化时间：第一次优化后

这里的export这种写法是有问题的：

```ts 
// core/index.ts
...
export * from '@salmon-element/components';
...
```

在执行打包后，我们先来看到dist/types/core/index.d.ts文件（打包后的产物）。中间的这个从components中全部导出，写法是错误的，因为打包后的产物是不包含packages/components这个文件夹的，我们需要的是打包后的产物里在dist/types/core与core平级的components文件夹，所以需要一些步骤来转换一下：把最终生成的dist/types/core/index.d.ts里的这部分替换成相对路径下的components

```ts
// dist/types/core/index.d.ts
declare const installer: import('vue').Plugin;
export * from '@salmon-element/components';
export default installer;
```

我们来到根目录下的tsconfig.build.json进行修改，就可以解决上面的问题

顺带一提，这里的"types": ["node"],是为了解决build里的关于process的打包报错，process是node.js里的全局变量|模块，加上了这句话：这意味着 TypeScript 编译器会自动引入 Node.js 的类型定义，从而使得在项目中可以使用 Node.js 的全局变量和模块（如 `process`、`Buffer` 等）。

```json
{
    ...
    /* Linting */
		...
		"types": ["node"],
		"baseUrl": "./",
		"paths": {
			"@salmon-element/components": ["./packages/components"]
		}
}
```



#### 关于打包的Icon的优化

问题：

在打包后的（非压缩模式下的）产物中，我们发现es里的Button的js文件里有一个`_export_sfc`的函数定义导出，而实际上每个组件都需要这个`_export_sfc`函数，结果发现后面的每一个组件都是从Button的js文件里引入的这个函数，而Icon组件也不例外。

实际上，Button组件需要引入Icon，而Icon又需要引入Button的`_export_sfc`函数，最终导致报错。

有一个很直接暴力的解决办法，就是在packages/components/index.ts中修改export的顺序，使得export Icon 在export Button上面，但这并不是一劳永逸的办法，后面写新的组件可能还要去调整。而且导出的es文件夹产物下的js文件的文件名都是有哈希部分的，当改变Button时，其他有关的js文件的文件名的哈希都会相应改变。

一劳永逸的方式，就是把`_export_sfc`函数导出，单独提到一个通用的逻辑里，不过我不必要单独生成一个文件（大材小用），我们把它合并到utils文件里就好

在vite.es.config.ts文件中

```ts
...
export default defineConfig({
	build: {
		...
		rollupOptions: {
			...
			output: {
				...
				manualChunks(id) {
					...
					if (includes(id, '/packages/utils') || includes(id, 'plugin-vue:export-helper'))
						return 'utils';
					...
				},
			},
		},
	},
});
```



#### 一些打包的优化

在vite.es.config.ts文件中，build配置项里有一个属性minify，我们可以设置成值为false

先引入：在core下执行 pnpm add terser @rollup/plugin-terser -D ， 这条指令的意思是从rollup里引进这个terser插件，但是我们项目里rollup这个文件目录，所以可能会报错，不过vite完全兼容rollup，虽然报错但可正常运行

再配置：在plugin里写配置，实现条件编译（在不同的生产、开发、测试环境下进行不同的编译）

```ts
// vite.es.config.ts
...
// 是生产环境吗
const isProd = process.env.NODE_ENV === 'production';
// 是开发环境吗
const isDev = process.env.NODE_ENV === 'development';
// 是测试环境吗
const isTest = process.env.NODE_ENV === 'test';
...
export default defineConfig({
	plugins: [
        ...
        terser({
			compress: {
				sequences: isProd,
				arguments: isProd,
				drop_console: isProd && ['log'],
				drop_debugger: isProd,
				passes: isProd ? 4 : 1,
				global_defs: {
					'@DEV': JSON.stringify(isDev),
					'@PROD': JSON.stringify(isProd),
					'@TEST': JSON.stringify(isTest),
				},
			},
			format: {
				semicolons: false,
				shorthand: isProd,
				braces: !isProd,
				beautify: !isProd,
				comments: !isProd,
			},
			mangle: {
				toplevel: isProd,
				eval: isProd,
				keep_classnames: isDev,
				keep_fnames: isDev,
			},
		}),
    ],
        build:{
            ...
            minify:false,
            ...
        }
});
```

同样的，在vite.umd.config.ts下做类似的修改

```ts
// vite.umd.config.ts
...
const isProd = process.env.NODE_ENV === 'production';
const isDev = process.env.NODE_ENV === 'development';
const isTest = process.env.NODE_ENV === 'test';
...
export default defineConfig({
	plugins:[
        ...
        terser({
			compress: {
				drop_console: ['log'],
				drop_debugger: true,
				passes: 3,
				global_defs: {
					'@DEV': JSON.stringify(isDev),
					'@PROD': JSON.stringify(isProd),
					'@TEST': JSON.stringify(isTest),
				},
			},
		}),
            ],
        ...
});
```

那么问题来了，我们如何去切换是生产环境、还是开发环境、还是测试环境呢，也就是切换NODE_ENV，我们需要去安装一个东西：pnpm add cross-env -wD，装到根目录

然后我们在packages/core下创建一个printLogo.ts，用于条件编译

```ts
export default function () {
	if (PROD) {
		const logo = `
____________________________________________________

  _____   _                     __     __  _       
 |_   _| | |                    \ \   / / (_)      
   | |   | |     _____   _____   \ \_/ /   _   ___ 
   | |   | |    / _ \ \ / / _ \   \   /   | | / __|
  _| |_  | |___| (_) \ V /  __/    | |    | | \__ \
 |_____| |______\___/ \_/ \___|    |_|    |_| |___/
                                                  
____________________________________________________
                 author:superSalmon
`;

		const rainbowGradient = `
background: linear-gradient(135deg, orange 60%, cyan);
background-clip: text;
color: transparent;
font-size: 16px; 
line-height: 1;
font-family: monospace;
font-weight: 600;
`;

		console.info(`%c${logo}`, rainbowGradient);
	} else if (DEV) {
		console.log('[EricUI]:dev mode...');
	}
}
```

项目根目录下创建env.d.ts

```ts
declare const PROD: boolean;
declare const DEV: boolean;
declare const TEST: boolean;
```

在根目录的tsconfig.build.json和tsconfig.json中的最下面的include中增加“env.d.ts”，增加完之后，printLogo.ts的有关PROD、DEV、TEST的报错就没了

接着再来做一些小处理，如果我们在run test的时候用到了PROD、DEV、TEST这几个词，会跑不通，所以我们在package/components/vitest.config.ts中增加点内容

```ts
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import vueJsx from '@vitejs/plugin-vue-jsx';

// https://vitejs.dev/config/
export default defineConfig({
	plugins: [vue(), vueJsx()],
	define: {
		PROD: JSON.stringify(false),
		DEV: JSON.stringify(false),
		TEST: JSON.stringify(true),
	},
	...
});
```

然后就可以来改造core下的package.json的scripts了

```json
"scripts": {
		"build": "run-p build-es build-umd",
		"build:watch": "run-p build-es:watch build-umd:watch",
		"build-umd": "vite build --config vite.umd.config.ts",
		"build-es": "vite build --config vite.es.config.ts",
		"build-umd:watch": "vite build --watch --config vite.umd.config.ts",
		"build-es:watch": "vite build --watch --config vite.es.config.ts",
		"release": "release-it"
	},
```

补充下build里的--watch是做甚麽的：在 Vite 的构建命令中，`--watch` 参数的作用是启用文件监听模式，使得 Vite 在构建完成后继续监听文件系统的变化，并在文件发生更改时自动重新触发构建（热更新）



改造根项目下的package.json里的scripts了，加一些cross-env之类的

```json
"scripts": {
		"dev": "pnpm run build && pnpm --filter @salmon-element/play run dev ",
		"story": "pnpm run build && pnpm --filter @salmon-element/play run storybook",
		"docs:dev": "pnpm --filter @salmon-element/docs run dev ",
		"docs:build": "pnpm --filter @salmon-element/docs run build",
		"test": "cross-env NODE_ENV=test pnpm --filter @salmon-element/components run test",
		"build": "cross-env NODE_ENV=production pnpm --filter salmon-element run build",
		"build:dev": "cross-env NODE_ENV=devlopment pnpm --filter salmon-element build:watch"
	},
```

然后就可以热更新啦！

先npm run build:dev，再新开一个终端运行别的调试比如npm run dev



#### 优化storybook实现按需引入css

①在paly/.storybook/preview.js中重新引入core/dist/theme/index.css，因为上面改了index.css的导出位置

②在每个组件的story测试stories.ts文件中单独引入对应组件的样式





### 第二次优化

时间：vitepress教程之后

#### 移动样式同步改异步，减少打包时间

core/build/vite.es.config.ts下修改成以下这里的函数moveStyles

```ts
// 打包时的样式文件移动位置
const TRY_MOVE_STYLES_DELAY = 800 as const;
function moveStyles() {
	readdir('./dist/es/theme', err => {
		if (err) {
			return delay(moveStyles, TRY_MOVE_STYLES_DELAY);
		}
		defer(() => shell.mv('./dist/es/theme', './dist'));
	});
}
```



#### 帮我们可视化打包时各文件大小的插件

npm install --save-dev rollup-plugin-visualizer

https://github.com/btd/rollup-plugin-visualizer

会生成静态html来可视化

配置也很简单：如下两个config文件

```ts
// vite.es.config.ts
...
export default defineConfig({
	plugin:[
        ...
        visualizer({
			filename: 'dist/stats/es.html', // 这里是那个html的导出路径
		}),
        ...
        ]
        ...
});
```

```ts
// vite.umd.config.ts
...
export default defineConfig({
	plugin:[
        ...
        visualizer({
			filename: 'dist/stats.umd.html', // 这里是那个html的导出路径
		}),
        ...
        ]
        ...
});
```



